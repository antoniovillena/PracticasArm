\input{hackcapitulo.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapterbegin{Introducción al ensamblador}
\label{chp:IntrEnsam}
\minitoc

{\bf Objetivo}:
En esta sesión vamos a conocer el entorno de trabajo.
Veremos qué aspecto tiene un programa en ensamblador, veremos cómo
funcionan los tres programas que vamos a utilizar: el ensamblador,
el {\it enlazador (linker)} y el {\it depurador (debugger)}.
Del {\it debugger} sólo mostraremos unos pocos comandos,
que ampliaremos en las próximas sesiones.
También veremos la representación de los números naturales y de los
enteros, y el funcionamiento de algunas de las instrucciones del ARM.
Se repasarán también los conceptos de registros, flags e instrucciones
para la manipulación de bits.

\section{Lectura previa}

\subsection{Características generales de la arquitectura ARM}

ARM es una arquitectura RISC (Reduced Instruction Set Computer=Ordenador
con Conjunto Reducido de Instrucciones) de 32 bits, salvo la versión del
core ARMv8-A que es mixta 32/64 bits (bus de 32 bits con registros de 64
bits). Se trata de una arquitectura licenciable, quiere decir que la
empresa desarrolladora ARM Holdings diseña la arquitectura, pero son
otras compañías las que fabrican y venden los chips, llevándose ARM
Holdings un pequeño porcentaje por la licencia.

%\begin{figure}[h]
%  \centering
%    \includegraphics[width=13cm]{graphs/ArmRoadMap.jpg}
%  \caption{Clasificación de Familias ARM}
%  \label{fig:clasif_fami}
%\end{figure}

El chip en concreto que lleva la Raspberry Pi es el BCM2835, se trata de
un SoC (System on a Chip=Sistema en un sólo chip) que contiene además de
la CPU otros elementos como un núcleo GPU (hardware acelerado OpenGL
ES/OpenVG/Open EGL/OpenMAX y decodificación H.264 por hardware) y un
núcleo DSP (Digital signal processing=Procesamiento digital de señales)
que es un procesador más pequeño y simple que el principal, pero
especializado en el procesado y representación de señales analógicas.
La CPU en cuestión es la ARM1176JZF-S, un chip de la familia ARM11 que
usa la arquitectura ARMv6k. 

\begin{longtable}{| p{4.2cm} | p{2.5cm} | p{1cm} | p{6cm} |}
\hline
{\bf Familia} & {\bf Arquitectura} & {\bf Bits} & {\bf Ejemplos de dispositivos} \\ \hline
ARM1      & ARMv1       & 32/26 & Segundo procesador BBC Micro \\ \hline
ARM2, ARM3, Amber & ARMv2      & 32/26 & Acorn Archimedes \\ \hline
ARM6, ARM7 & ARMv3      & 32 & Apple Newton Serie 100 \\ \hline
ARM8, StrongARM & ARMv4       & 32 & Apple Newton serie 2x00 \\ \hline
ARM7TDMI,\newline ARM9TDMI & ARMv4T & 32 & Game Boy Advance \\ \hline
ARM7EJ, ARM9E,\newline ARM10E, XScale & ARMv5 & 32 & Samsung Omnia,\newline Blackberry 8700 \\ \hline
ARM11     & ARMv6 & 32 & iPhone 3G, Raspberry Pi \\ \hline
Cortex-M0/M0+/M1 & ARMv6-M & 32 & \\ \hline
Cortex-M3/M4 & ARMv7-M ARMv7E-M & 32 & Texas Instruments Stellaris \\ \hline
Cortex-R4/R5/R7 & ARMv7-R & 32 & Texas Instruments TMS570 \\ \hline
Cortex-A5/A7/A8/A9\newline A12/15/17, Apple A6 & ARMv7-A & 32 & Apple iPad \\ \hline
Cortex-A53/A57, X-Gene, Apple A7 & ARMv8-A & 64/32 & Apple iPhone 5S\\ \hline
\caption{Lista de familias y arquitecturas ARM}
\label{list_fam}
\end{longtable}

Las extensiones de la arquitectura ARMv6k frente a la básica ARMv6 son mínimas
\footnote{\url{http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0301h/apbs02s02.html}}
por lo que a efectos prácticos trabajaremos con la arquitectura ARMv6.

\subsubsection{Registros}
La arquitectura ARMv6 presenta un conjunto de 17 registros (16 principales
más uno de estado) de 32 bits cada uno.
\newline

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/registros.png}
  \caption{Registros de la arquitectura ARM}
  \label{fig:reg_arm}
\end{figure}

\begin{descript}
  \item[Registros Generales.]
    Su función es el almacenamiento temporal de datos. Son los 13 registros
    que van R0 hasta R12.
  \item[Registros Especiales.]{
    Son los últimos 3 registros principales: R13, R14 y R15. Como son de
    propósito especial, tienen nombres alternativos.}

    \begin{itemize}
      \item{\textbf{SP}/R13. Stack Pointer ó Puntero de Pila. Sirve como puntero para almacenar
        variables locales y registros en llamadas a funciones.}
      \item{\textbf{LR}/R14. Link Register ó Registro de Enlace. Almacena la dirección de retorno
        cuando una instrucción BL ó BLX ejecuta una llamada a una rutina.}
      \item{\textbf{PC}/R15. Program Counter ó Contador de Programa. Es un registro que indica
        la posición donde está el procesador en su secuencia de instrucciones. Se
        incrementa de 4 en 4 cada vez que se ejecuta una instrucción, salvo que ésta
        provoque un salto.}
    \end{itemize}

  \item[Registro CPSR.]{}

\end{descript}

\chapterend{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}