\input{hackcapitulo.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapterbegin{Interrupciones hardware}
\label{chp:Interrupciones}
\minitoc

{\bf Objetivos}: En esta sesión vamos a realizar programas que
utilizan dispositivos de E/S haciendo uso del sistema de
interrupciones hardware. Para poder programar los distintos parámetros
que configuran el entorno de las interrupciones es necesario conocer de
forma detallada cómo funcionan los registros asociados, ya que
éste es el mecanismo mediante el cual el procesador se
comunica con los periféricos.

Hacemos incapié en lo de {\it hardware} porque las
{\it interrupciones software} no son más que las llamadas a sistema
que vimos en el capítulo anterior. Ambas comparten vector de interrupciones,
pero las {\it interrupciones software} son más bien llamadas a subrutinas.

\section{Lectura previa}

\subsection{Hardware necesario}

Como vamos a seguir trabajando en {\it Bare Metal} y la complejidad
de los ejemplos va en aumento, no nos queda más remedio que
recurrir a hardware externo a la Raspberry para poder seguir. Se
trata de una placa sencilla, con 2 pulsadores, 6 LEDs y un altavoz
piezoeléctrico.

\begin{longtable}{ p{1.8cm} | p{1.2cm} | p{2cm} | p{5cm}}
\hline
{\bf Nombre} & {\bf GPIO} & {\bf Tipo} & {\bf Descripción} \\ \hline
LED1 & 0/2 & Salida & Diodo led color rojo \\ \hline
LED2 & 1/3 & Salida & Diodo led color rojo \\ \hline
LED3 & 17 & Salida & Diodo led color amarillo \\ \hline
LED4 & 22 & Salida & Diodo led color amarillo \\ \hline
LED5 & 10 & Salida & Diodo led color verde \\ \hline
LED6 & 11 & Salida & Diodo led color verde \\ \hline
BOT1 & 21/27 & Entrada & Pulsador izquierdo \\ \hline
BOT2 & 9 & Entrada & Pulsador derecho \\ \hline
ALT & 4 & Salida & Altavoz piezoeléctrico \\ \hline
\label{tab:berry}
\end{longtable}

Es un circuito sencillo y se puede montar en una protoboard sin
problemas, el esquema es el siguiente.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/circuito.png}
  \caption{Esquema del circuito}
  \label{fig:circuito}
\end{figure}

También se pueden adquirir por internet tarjetas similares, aunque cableadas
a distintos puertos GPIO, por lo que habría que hacer los respectivos cambios
en el código de los ejemplos.

\subsection{Conceptos previos}

Una interrupción es una petición que se hace a la CPU para que detenga el
trabajo que esté realizando y ejecute una rutina determinada. Es uno de los
dos métodos que hay para comunicarse con los periféricos. El otro método,
que ya hemos usado en el capítulo anterior, se llama {\it Polling} y no es
más que una consulta constante sobre el estado de un periférico o un envío
continuo de información.

Existe otro concepto llamado {\it Excepción} que es muy ambiguo. Normalmente
una excepción es una situación de error detectada por la CPU mientras ejecuta
una instrucción, que requiere tratamiento por parte del sistema operativo.
Sin embargo en lo que a arquitectura ARM se refiere, el concepto {\it Excepción}
es diferente. Se trata de un caso general y abarca interrupciones hardware,
interrupciones software y el caso particular de {\it excepción} que explicamos
antes.

Por último tenemos el vector de excepciones, que no es más que una serie de
direcciones a las que la CPU saltará según el tipo de excepción que se produzca.
Lo más normal es que la base del vector de excepciones sea la dirección {\tt 0x00000000},
o sea la dirección más baja de memoria, aunque se puede cambiar dicha dirección base.
La lista del vector de excepciones es la siguiente.

\begin{longtable}{ p{5cm} | p{2cm} | p{4cm}}
\hline
{\bf Excepción} & {\bf Desplaz.} & {\bf Modo} \\ \hline
Reset                   & {\tt 0x00} & Supervisor \\ \hline
Instrucción no definida & {\tt 0x04} & No definido \\ \hline
Interrupción software   & {\tt 0x08} & Supervisor \\ \hline
Error en prefetch       & {\tt 0x0C} & Abort \\ \hline
Error en datos          & {\tt 0x10} & Abort \\ \hline
Reservado               & {\tt 0x14} & Reservado \\ \hline
IRQ                     & {\tt 0x18} & IRQ \\ \hline
FIQ                     & {\tt 0x1C} & FIQ \\ \hline
\end{longtable}

La última columna se refiere al {\it Modo de operación} que comentamos en el primer
capítulo, es un estado en el que se encuentra el procesador con una serie de privilegios
con respecto a otros modos y que gracias a ellos podemos construir un sistema operativo
con diferentes capas. Cada modo tiene sus propios registros {\tt sp} y {\tt lr} de tal
forma que no alteramos la pila de la secuencia de programa que interrumpimos. Incluso
el modo {\tt FIQ} tiene 5 registros generales propios (desde {\tt r8} hasta {\tt r12}),
de esta forma si los empleamos en nuestra rutina de tratamiento no tendremos que
salvaguardarlos en pila.

{\it Reset} es la excepción que se produce al forzar un reinicio en dicha máquina. La
Raspberry no tiene pulsador de reset, pero sí un par de pines (sin montar) para que podamos
añadir un pulsador externo. Este conector se llama {\tt P6} en la Raspberry original y
{\tt RUN} en el modelo B+.

{\it Instrucción no definida} se produce cuando en el flujo de instrucciones nos encontramos
un código de operación que no se corresponde con ninguna instrucción. Normalmente esto se
produce por una corrupción en la memoria de programa o bien que hemos saltado erróneamente
a una zona donde hay datos. También se puede dar el caso de que intentemos ejecutar código
ARM para una plataforma más moderna y nos encontremos con una instrucción no soportada por el
procesador que tenemos.

Las {\it interrupciones software} ya las hemos visto, son las que se invocan con la
instrucción {\tt swi \#n}.

Luego tenemos los errores en {\it prefetch} y {\it datos}. Un error de {\it prefetch} se produce
cuando tratamos de ejecutar una instrucción que momentos antes hemos modificado. Es poco
frecuente y para que se produzca debemos escribir código que sea automodificable, que es
una práctica no deseable y apenas utilizada en dicha arquitectura. Los errores de {\it datos}
son generados normalmente por el manejador de memoria y responden a fallos de alineación, de
traslación, de dominio o de permisos.

Lo siguiente es una entrada reservada, no tiene ninguna funcionalidad ahora
pero es probable que en futuras extensiones sí que la tenga.

Por último están las excepciones que nos interesan y que trataremos en este capítulo, que son
las interrupciones normales {\tt IRQ} y las interrupciones rápidas {\tt FIQ}.

\subsection{Rutina de tratamiento de interrupción}

Es el segmento de código que se ejecuta para atender a una interrupción. Una vez se haya
ejecutado dicha rutina, retomamos la ejecución normal de nuestro programa, justo en la instrucción en
donde lo habíamos interrumpido. Cada rutina de tratamiento debe atender a todas las posibles
fuentes de interrupción de su mismo tipo, con lo que al comienzo de la interrupción se suelen
acceder a los registros asociados para detectar qué periférico ha causado la excepción y
actuar en consecuencia.

Como sólo nos interesan {\tt IRQ} y {\tt FIQ}, a lo sumo sólo tendremos que escribir dos
rutinas de tratamiento distintas. Si se produce una {\tt IRQ}, se ejecutará el código
que se encuentre en la dirección {\tt 0x0018}, mientras que si lo que salta es una {\tt IRQ},
la dirección a ejecutar será {\tt 0x001C}. La diferencia entre una {\tt IRQ} y una
{\tt FIQ} es que esta última tiene sus propios registros desde {\tt r8} hasta {\tt r12}
asociados al modo de operación, con lo que podemos prescindir del salvado y recuperación
de estos registros en la RTI, ahorrando un tiempo que en determinadas aplicaciones de
tiempo real puede ser decisivo.

El esqueleto de una RTI es el siguiente.

\begin{lstlisting}
irq_handler:
        push    {lista registros}
        ...
        pop     {lista registros}
        subs    pc, lr, #4
\end{lstlisting}

Vemos que a diferencia de las subrutinas donde salíamos con {\tt lr}, en una RTI salimos
con {\tt lr-4}, a ello se debe la última instrucción. ¿Y porqué hay un sufijo {\tt s} al final
de la instrucción {\tt sub}? Pues porque se trata de instrucción especial que sirve para
restaurar el registro {\tt cpsr} que había antes de la interrupción.

Cada modo de operación tiene 3 registros replicados: {\tt sp}, {\tt lr} y {\tt spsr}. Cuando
ocurre una interrupción pasamos de modo supervisor a modo IRQ. Los registros {\tt sp}
y {\tt lr} del modo supervisor no se tocan para nada, con lo que tenemos nuestra propia pila
de interrupciones IRQ. El registro {\tt lr} (asociado a IRQ) se carga apuntando a la
instrucción que va después de donde se ha producido la excepción. Además se hace una copia
del registro {\tt cpsr} a otro llamado {\tt spsr} (Saved Program Status Register), porque
dentro de la RTI es probable que queramos modificar {\tt cpsr} y también porque el hecho
de cambiar de modo de operación a IRQ ya ha modificado el registro {\tt cpsr}.

Al terminar la interrupción restauramos {\tt pc} partiendo {\tt lr} y {\tt cpsr} del registro
{\tt spsr}. Al cambiar de modo volvemos al {\tt sp} y {\tt lr} que teníamos en dicho modo,
el resto de registros es responsabilidad nuestra devolverlos al valor que tenían al entrar
en la RTI. Con todo esto conseguimos volver exactamente al punto del que partíamos minimizando las
operaciones que tiene que hacer la RTI y por tanto el retardo asociado. En otras arquitecturas
además de delegar en la RTI este trabajo, se usa la misma pila de programa, lo que puede
ocasionar problemas si nos importa lo que hay debajo de ésta.

\subsection{Inicialización en programa principal}

En realidad la inicialización es lo único que vamos a tener en nuestro programa principal,
puesto que una vez configuradas las interrupciones vamos a controlar el comportamiento del
programa con las mismas. Es decir, nuestro programa principal tras la inicialización será una
instrucción que salta a sí misma continuamente, la misma {\tt infi: b infi} del capítulo
anterior salvo que esta vez no la usamos para dejar al sistema colgado.

El orden recomendado es el siguiente, aunque se pueden cambiar el mismo salvo el último punto.

\begin{itemize}
  \item Escribimos en el vector de excepciones de la dirección de comienzo de la RTI que vayamos
        a usar. En nuestros ejemplos tendremos IRQs y FIQs, por lo que como mucho haremos dos
        escrituras (para dos RTIs distintas).
  \item Inicializamos el puntero de pila (registro {\tt sp}) en todos los modos de operación.
        Tienen que apuntar a zonas distintas dondo sepamos que no habrá conflictos con la
        memoria de programa. En todos los ejemplos que veremos inicializamos la pila de FIQ
        a {\tt 0x4000}, la de IRQ a {\tt 0x8000} y la del modo Supervisor a {\tt 0x8000000}.
  \item Escribimos código de inicialización ajeno al proceso de interrupción, como por ejemplo
        configurar los GPIOs a salidas donde queramos que actúe un LED.
  \item Ahora viene la inicialización de las interrupciones. Aquí le decimos al sistema qué fuentes
        pueden provocar interrupciones, escribiendo en los registros asociados. 
  \item El último paso es habilitar las interrupciones globalmente escribiendo en el registro
        {\tt cpsr}. Lo hacemos indirectamente vía otro registro, y la instrucción tiene otro
        nombre pero hace lo mismo que un {\tt mov}. En concreto se llama {\tt msr}, y también hay
        otra equivalente {\tt mrs} si lo que queremos es leer de {\tt cpsr} a un registro.
  \item Después de esto se acaba la inicialización y tendríamos el bucle infinito del que consta
        nuestro programa principal. Si todo ha ido bien las rutinas de tratamiento de interrupción
        se encargarán de hacer funcionar nuestro programa como queramos.
\end{itemize}

Existen mucha formas de escribir en el vector de excepciones. Se puede rellenar toda la tabla
y hacer un copiado, o ir escribiendo uno a uno los vectores. También hay varias formas de hacer
los saltos dentro de la tabla, mediante un salto sencillo que está limitado a +/- 32Mb, o usando
la instrucción {\tt ldr pc, =valor}. Esta última requiere 4 bytes adicionales, pero a su favor
tiene que no hay limitaciones en el salto y que podemos escribir directamente la dirección
absuluta de nuestra RTI.

Nosotros vamos a emplear una función que recibe dos parámetros (dirección de vector y dirección de
RTI) y que se encargará él mismo de introducir una instrucción de salto en el lugar adecuado.

\begin{lstlisting}
add_exception:
        sub     r1, r0
        lsr     r1, #2
        sub     r1, #2
        orr     r1, #0xea000000
        str     r1, [r0]
        bx      lr
\end{lstlisting}

Habría que hacer tantas llamadas a esta función como tipos de excepciones tengamos. Luego tenemos
que inicializar los punteros de pila de los distintos modos de operación. Desde el punto de vista
del ensamblador todos los registros se llaman igual, no podemos acceder a ellos por los sufijos.
Queremos inicializar {\tt r13\_svc (sp\_svc)}, {\tt r13\_fiq (sp\_fiq)} y {\tt r13\_svc (sp\_fiq)}, y
de estos dos últimos sólo el que vayamos a emplear en nuestro programa. En la figura 
\ref{fig:tablareg} tenemos los distintos registros.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/tablaregistros.png}
  \caption{Registros según modo de operación}
  \label{fig:tablareg}
\end{figure}

La única forma de acceder a ellos es cambiando de modo y modificando el registro {\tt sp}. En
modo {\tt Bare Metal} nos olvidamos del modo Usuario, el sistema arranca en modo Supervisor y
nosotros nos mantenemos en dicho modo a no ser que haya una interrupción, o querramos cambiar
un registro particular del modo como es el caso.

El modo viene indicado en la parte más baja del registro {\tt cpsr}, el cual modificaremos
con la instrucción especial {\tt msr}. Como sólo nos interesa cambiar el byte más bajo del
registro, añadimos el sufijo {\tt c} precedido de un guión bajo. Los otros 3 bytes se acceden
con {\tt x}, {\tt s} y {\tt f} respectivamente. En la figura \ref{fig:cpsr} vemos el contenido
completo del registro {\tt cpsr}.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/cpsr.png}
  \caption{Registro cpsr}
  \label{fig:cpsr}
\end{figure}

Y en la siguiente tabla vemos cómo se codifica el modo de operación.

\begin{longtable}{ p{1.8cm} | p{2cm} | p{5cm} | p{1cm} | p{1cm} }
\hline
{\bf Hex} & {\bf Binario} & {\bf Modo de operación} \\ \hline
0x10 & 10000 & Usuario        \\ \hline
0x11 & 10001 & FIQ            \\ \hline
0x12 & 10010 & IRQ            \\ \hline
0x13 & 10011 & Supervisor     \\ \hline
0x16 & 10110 & Monitor seguro \\ \hline
0x17 & 10111 & Abort          \\ \hline
0x1B & 11011 & Indefinido     \\ \hline
0x1F & 11111 & Sistema        \\ \hline
\end{longtable}

Finalmente tenemos que el código que inicializa los punteros de pila es el siguiente.

\begin{lstlisting}
        mov     r0, #0xd1     @FIQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x4000
        mov     r0, #0xd2     @IRQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000
        mov     r0, #0xd3     @SVC mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000000
\end{lstlisting}

En concreto a {\tt 0x4000}, {\tt 0x8000} y {\tt 0x8000000} para los modos {\tt FIQ}, {\tt IRQ} y
{\tt Supervisor} respectivamente.

La inicialización de las interrupciones es bastante específica, por lo que la veremos en los
respectivos ejemplos. Y por último tenemos que habilitar las interrupciones globalmente, poniendo
a cero el bit correspondiente en {\tt cpsr}, y que en el caso de habilitar IRQs sería así.

\begin{lstlisting}
        mov     r0, #0x53     @SVC mode, IRQ enable
        msr     cpsr_c, r0
\end{lstlisting}

\subsection{Ejemplos de aplicación}

Todos los ejemplos que vamos a listar son para la placa que usaremos en el laboratorio
y para los siguientes modelos de Raspberry.

\begin{itemize}
  \item Modelo A.
  \item Modelo B revisión 2.0.
  \item Modelo B+ (empleando la parte izquierda del conector).
\end{itemize}

El modelo B revisión 1.0 tiene una asignación de pines ligeramente distinta, cambiando 3 de
los pines. Si dispones de esta versión tendrías que modificar el código de los ejemplos
según la tabla \ref{tab:berry}.

\subsection{Parpadeo de todos los LEDs}

Sería hacer lo mismo que en la lección anterior pero empleando interrupciones y aplicando
la salida simultáneamente a los 6 LEDs de la placa externa en lugar del LED que incluye
la Raspberry. La cadencia debe ser de un segundo.

Vamos a emplear otro temporizador, el {\tt System Timer}, distinto al de la lección anterior
que era el {\tt ARM Timer}. Los registros asociados al temporizador son los de la figura
\ref{fig:systim}.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/systemtimer.png}
  \caption{System Timer}
  \label{fig:systim}
\end{figure}

Básicamente con un contador de 64 bits y cuatro comparadores. El temporizador funciona a 1MHz,
por lo que cada microsegundo se incrementa la cuenta del contador. Está dividido en dos partes,
la parte baja {\tt CLO} y la parte alta {\tt CHI}. La parte alta no nos resulta interesante,
porque tarda poco más de una hora en incrementarse y no va asociado a ningún comparador. Los
comparadores son registros que se pueden modificar y se comparan con {\tt CLO}, en el momento
que uno de los 4 comparadores coincida y estén habilitadas las interrupciones para dicho
comparador, se produce una interrupción y se activa el correspondiente {\tt Mx}
asociado a {\tt CS} (para que en la RTI sepamos qué comparador ha provocado la interrupción).
Los comparadores {\tt C0} y {\tt C2} los emplea la GPU internamente, por lo que en nuestros
ejemplos nos ceñiremos a los comparadores {\tt C1} y {\tt C3}.

El temporizador ya está, luego tenemos los registros asociados a las interrupciones en la figura
\ref{fig:interrupciones}.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/interrupciones.png}
  \caption{Interrupciones}
  \label{fig:interrupciones}
\end{figure}

En este caso las {\tt FIQs} sólo tienen un registro de control asociado, quedando todo el detalle
en las {\tt IRQs}. Nosotros vamos a usar las {\tt IRQs} en este ejemplo. Hay tres grupos de tres
registros cada uno. El primer grupo sirve para indicar que hay una interrupción pendiente, el
segundo es para habilitar las interrupciones y el tercero para deshabilitarlas. Dentro de cada
grupo tenemos un registro básico que tiene una mezcla de todo y otros dos registros que
indican con más detalle la fuente de la interrupción. Dentro de la mezcla del registro básico
hay fuentes individuales {\tt GPU IRQ x} y bits que engloban a varias fuentes {\tt Bits in PR1},
que por ejemplo indica que el origen hay que buscarlo en el registro 1. En el registro 1 están
las primeras 32 posiciones de la tabla de interrupciones, mientras que en el registro 2 están
las 32 últimas.

La documentación oficial sobre la tabla de interrupciones está incompleta, pero buscando un poco
por internet se puede encontrar que las interrupciones asociadas al {\tt System Timer} se
controlan con los 4 primeros bits de la tabla (uno para cada comparador).

Ya estamos en condiciones para mostrar el código del ejemplo.

\begin{lstlisting}[caption={inter1.c},label={lst:codigoPract5_1},escapeinside={@}{@}]
        .set    GPBASE,   0x20200000
        .set    GPFSEL0,        0x00
        .set    GPFSEL1,        0x04
        .set    GPFSEL2,        0x08
        .set    GPSET0,         0x1c
        .set    GPCLR0,         0x28
        .set    STBASE,   0x20003000
        .set    STCS,           0x00
        .set    STCLO,          0x04
        .set    STC1,           0x10
        .set    INTBASE,  0x2000b000
        .set    INTENIRQ1,     0x210
.text
        mov     r0, #0x18     @IRQ vector
        ldr     r1, =irq\_handler
        bl      add\_exception
        mov     r0, \#0xd2     @IRQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, \#0x8000
        mov     r0, #0xd3     @SVC mode, FIQ\&IRQ disable
        msr     cpsr\_c, r0
        mov     sp, \#0x8000000
        ldr     r0, =GPBASE
        mov     r1, \#0b00000000000000000000001001000000
        str     r1, [r0, \#GPFSEL0]
        ldr     r1, =0b00000000001000000000000000001001
        str     r1, [r0, \#GPFSEL1]
        mov     r1, \#0b00000000000000000000000001000000
        str     r1, [r0, \#GPFSEL2]
        ldr     r0, =STBASE
        ldr     r1, [r0, \#STCLO]
        add     r1, \#1
        str     r1, [r0, \#STC1]
        ldr     r0, =INTBASE
        mov     r1, \#0b0010
        str     r1, [r0, \#INTENIRQ1]
        mov     r0, \#0x53     @SVC mode, IRQ enable
        msr     cpsr_c, r0
bucle:  b       bucle

add_exception:
        sub     r1, r0
        lsr     r1, #2
        sub     r1, #2
        orr     r1, #0xea000000
        str     r1, [r0]
        bx      lr

irq_handler:
        push    {r0, r1, r2}
        ldr     r0, =ledst
        ldr     r1, [r0]
        eors    r1, #1
        str     r1, [r0]
        ldr     r0, =GPBASE
        ldr     r1, =0b00000000010000100000110000001100
        streq   r1, [r0, #GPSET0]
        strne   r1, [r0, #GPCLR0]
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        ldr     r2, =500000       @1 Hz
        add     r1, r2
        str     r1, [r0, \#STC1]
        mov     r1, \#0b0010
        str     r1, [r0, \#STCS]
        pop     {r0, r1, r2}
        subs    pc, lr, \#4

ledst:  .word   0
\end{lstlisting}

Y vamos enumerando, por orden, los pasos que hemos seguido. En primer lugar apuntamos a nuestra
RTI en el vector de excepciones.

\begin{lstlisting}
        mov     r0, #0x18     @IRQ vector
        ldr     r1, =irq_handler
        bl      add_exception
\end{lstlisting}

Luego inicializamos los punteros de pila.

\begin{lstlisting}
        mov     r0, #0xd2     @IRQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000
        mov     r0, #0xd3     @SVC mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000000
\end{lstlisting}

Lo siguiente es configurar los pines GPIO asociados a los 6 LEDs como salidas.

\begin{lstlisting}
        ldr     r0, =GPBASE
        mov     r1, #0b00000000000000000000001001000000
        str     r1, [r0, #GPFSEL0]
        ldr     r1, =0b00000000001000000000000000001001
        str     r1, [r0, #GPFSEL1]
        mov     r1, #0b00000000000000000000000001000000
        str     r1, [r0, #GPFSEL2]
\end{lstlisting}

Preparamos el comparador {\tt C1} para que al cabo de un microsegundo nos proporcione la primera
interrupción.

\begin{lstlisting}
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        add     r1, #1
        str     r1, [r0, #STC1]
\end{lstlisting}

Para después habilitar las interrupciones asociadas al comparador {\tt C1}.

\begin{lstlisting}
        ldr     r0, =INTBASE
        mov     r1, #0b0010
        str     r1, [r0, #INTENIRQ1]
\end{lstlisting}

Y finalmente habilitar las interrupciones {\tt IRQ} globalmente, entrando luego en
el bucle infinito.

\begin{lstlisting}
        mov     r0, #0x53     @SVC mode, IRQ enable
        msr     cpsr_c, r0
bucle:  b       bucle
\end{lstlisting}

Ya hemos terminado con el programa principal, que como veremos más adelante va a ser
siempre muy parecido.

Lo interesante está en la RTI, que es donde hacemos parpadear los LEDs y configuramos
el comparador para la siguiente interrupción.

El estado de los LEDs (si están apagados o encendidos) lo guardamos en la variable
{\tt ledst}, que conmutamos entre cero y uno mediante un {\tt OR} exclusivo. Al
actualizar los {\tt flags} tras esta operación, tenemos que si el resultado fue
cero nos lo indica el {\tt flag Z} activo, mientras que estará inactivo en el
caso contrario (resultado 1). Mediante las instrucciones de ejecución condicional
{\tt streq} y {\tt strne} enviamos la orden al puerto que enciende los LEDs o al
puerto que los apaga, respectivamente.

\begin{lstlisting}
irq_handler:
        push    {r0, r1, r2}
        ldr     r0, =ledst
        ldr     r1, [r0]
        eors    r1, #1
        str     r1, [r0]
        ldr     r0, =GPBASE
        ldr     r1, =0b00000000010000100000110000001100
        streq   r1, [r0, #GPSET0]
        strne   r1, [r0, #GPCLR0]
\end{lstlisting}

Luego tenemos que actualizar el registro comparador, de lo contrario tardará poco más
de una hora en cambiar de estado el LED (es lo que tarda el contador en dar una vuelta
completa). Para ello leemos el contador ({\tt CLO}) y le añadimos 500000 al valor leído. Como cada
cuenta equivale a un microsegundo, este añadido al contador supone medio segundo, lo
que nos da la cadencia de un segundo que buscamos. El resultado de la suma lo escribimos
en el comparador ({\tt C1}).

\begin{lstlisting}
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        ldr     r2, =500000       @1 Hz
        add     r1, r2
        str     r1, [r0, #STC1]
\end{lstlisting}

Luego escribimos un 1 en el {\tt M1} de {\tt CS}, para resetear el estado de coincidencia, ya
que de lo contrario el gestor de interrupciones verá el bit siempre a 1 y no lanzará más
interrupciones. Resulta confuso tener que escribir un 1 en el registro para almacenar un 0, pero
de un modo similar a lo que ocurre con el registro {\tt GPCLR0} del GPIO es para ahorrar
operaciones y que la RTI sea más rápida. Así no hay que leer el registro, aplicar una máscara y
volver a escribir en el mismo registro, con una escritura es suficiente.

Por último restauramos los registros utilizados y salimos de la RTI. Más abajo tenemos la
definición de la variable {\tt ledst}, como no tenemos sección de datos aparte la ponemos
al final del código.

\begin{lstlisting}
        mov     r1, #0b0010
        str     r1, [r0, #STCS]
        pop     {r0, r1, r2}
        subs    pc, lr, #4

ledst:  .word   0
\end{lstlisting}

\subsection{Parpadeo secuencial de LEDs con sonido por altavoz}

Vamos a complicar un poco las cosas. En la RTI anterior sabíamos de antemano que la única fuente
de interrupción es {\tt C1} del {\tt System Timer}. Por eso directamente hacíamos conmutar el
LED sin comprobar nada más, esto es porque sabemos que ningún otro evento provocará una {\tt IRQ}.

Ahora vamos a meter una segunda fuente de interrupción para controlar el altavoz. Sacar un tono
puro por el altavoz es equivalente a hacer parpadear un LED, lo único que cambia es que usamos
otro pin distinto {\tt GPIO 4} y aumentamos la frecuencia para que sea audible (a 1Hz el oído
humano no captaría sonido alguno). Utilizaremos la frecuencia estándar de afinación
de 440 Hz, que coincide con el tono de espera de marcado en la telefonía fija.

Por otro lado en lugar de hacer parpadear todos los LEDs lo que haremos es repetir una
secuencia de 6 posiciones en la que en todo momento sólo uno de los 6 LEDs está encendido, que
va cambiando de izquierda a derecha (aparentando movimiento) y cuando se llegue al sexto LED
comenzamos de nuevo desde el primero. Para dar más sensación de movimiento disminuimos el periodo
a 200 milisegundos.

La clave de todo está en saber cuál de los dos comparadores ha producido la interrupción (se
puede dar el caso en que salten los dos a la vez). Ésto se puede hacer de dos formas distintas:
o bien leemos el bit asociado {\tt systim\_cx} en el registro {\tt IRQ pending 1}, o bien leemos
el {\tt Mx} del registro {\tt CS}. Elegimos el segundo caso, así no gastamos otro registro más
para almacenar {\tt INTBASE}.

El código completo del ejemplo es el siguiente.

\begin{lstlisting}[caption={inter2.c},label={lst:codigoPract5_2},escapeinside={@}{@}]
        .set    GPBASE,   0x20200000
        .set    GPFSEL0,        0x00
        .set    GPFSEL1,        0x04
        .set    GPFSEL2,        0x08
        .set    GPSET0,         0x1c
        .set    GPCLR0,         0x28
        .set    STBASE,   0x20003000
        .set    STCS,           0x00
        .set    STCLO,          0x04
        .set    STC1,           0x10
        .set    STC3,           0x18
        .set    INTBASE,  0x2000b000
        .set    INTENIRQ1,     0x210
.text
        mov     r0, #0x18     @IRQ vector
        ldr     r1, =irq\_handler
        bl      add\_exception
        mov     r0, \#0xd2     @IRQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000
        mov     r0, #0xd3     @SVC mode, FIQ\&IRQ disable
        msr     cpsr\_c, r0
        mov     sp, \#0x8000000
        ldr     r0, =GPBASE
        mov     r1, \#0b00000000000000000001001001000000
        str     r1, [r0, \#GPFSEL0]
        ldr     r1, =0b00000000001000000000000000001001
        str     r1, [r0, \#GPFSEL1]
        mov     r1, \#0b00000000000000000000000001000000
        str     r1, [r0, \#GPFSEL2]
        ldr     r0, =STBASE
        ldr     r1, [r0, \#STCLO]
        add     r1, \#1
        str     r1, [r0, \#STC1]
        str     r1, [r0, \#STC3]
        ldr     r0, =INTBASE
        mov     r1, \#0b1010
        str     r1, [r0, \#INTENIRQ1]
        mov     r0, \#0x53     @SVC mode, IRQ enable
        msr     cpsr_c, r0
bucle:  b       bucle

add_exception:
        sub     r1, r0
        lsr     r1, #2
        sub     r1, #2
        orr     r1, #0xea000000
        str     r1, [r0]
        bx      lr

irq_handler:
        push    {r0, r1, r2, r3}
        ldr     r0, =STBASE
        ldr     r1, =GPBASE
        ldr     r2, [r0, #STCS]
        ands    r2, #0b0010
        beq     sonido
        ldr     r2, =cuenta
        ldr     r3, =0b00000000010000100000110000001100
        str     r3, [r1, #GPCLR0]
        ldr     r3, [r2]          @cuenta
        subs    r3, \#1
        movmi   r3, \#5
        str     r3, [r2], \#4      @cuenta
        ldr     r3, [r2, +r3, LSL #2]
        str     r3, [r1, #GPSET0]
        ldr     r3, [r0, #STCLO]
        ldr     r2, =200000       @5 Hz
        add     r3, r2
        str     r3, [r0, \#STC1]
        mov     r3, \#0b0010
        str     r3, [r0, \#STCS]
        ldr     r3, [r0, \#STCS]
        ands    r3, \#0b0100
        beq     final
sonido: ldr     r2, =bitson
        ldr     r3, [r2]
        eors    r3, \#1
        str     r3, [r2]
        mov     r3, \#0b10000      @altavoz
        streq   r3, [r1, \#GPSET0]
        strne   r3, [r1, \#GPCLR0]
        ldr     r3, [r0, \#STCLO]
        ldr     r2, =1136         @440 Hz
        add     r3, r2
        str     r3, [r0, \#STC3]
        mov     r3, \#0b1000
        str     r3, [r0, \#STCS]
final:  pop     {r0, r1, r2, r3}
        subs    pc, lr, \#4

bitson: .word   0
cuenta: .word   0
secuen: .word   0b00000000000100000000000
        .word   0b00000000000010000000000
        .word   0b10000000000000000000000
        .word   0b00000100000000000000000
        .word   0b00000000000000000001000
        .word   0b00000000000000000000100
\end{lstlisting}

Como es muy parecido al ejemplo de antes, sólo vamos a comentar las diferencias que encontremos.
La primera de ellas es que además de los 6 GPIOs de los LEDs, configuramos como salida un séptimo
pin, el GPIO 4, para manejar el altavoz.

\begin{lstlisting}
        ldr     r0, =GPBASE
        mov     r1, #0b00000000000000000001001001000000
        str     r1, [r0, #GPFSEL0]
\end{lstlisting}

El siguiente código es para incluir el comparador {\tt C3}, tanto para proporcionar la primera
interrupción como para habilitarla individualmente.

\begin{lstlisting}
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        add     r1, #1
        str     r1, [r0, #STC1]
        str     r1, [r0, #STC3]
        ldr     r0, =INTBASE
        mov     r1, #0b1010
\end{lstlisting}

Ya hemos acabado con el programa principal, veamos ahora la RTI. Primero explicamos mostramos
el esquema general y luego las rutinas individuales tanto para el manejo de LEDs como para el
altavoz.

\begin{lstlisting}
irq_handler:
        push    {r0, r1, r2, r3}
        ldr     r0, =STBASE
        ldr     r1, =GPBASE
        ldr     r2, [r0, #STCS]
        ands    r2, #0b0010
        beq     sonido

        [ manejo de LEDs ]

        str     r3, [r0, #STCS]
        ldr     r3, [r0, #STCS]
        ands    r3, #0b0100
        beq     final
sonido:
        [ manejo de altavoz ]

final:  pop     {r0, r1, r2, r3}
        subs    pc, lr, #4
\end{lstlisting}

Los registros {\tt r0} y {\tt r1} los hacemos apuntar a la base del {\tt System Timer} y del
{\tt GPIO} y no tocamos dichos valores durante toda la interrupción, vamos a estar
constantemente leyendo y escribiendo registros y no es plan de tener que cargar la
base cada vez.

Es un error muy habitual suponer que la fuente de la interrupción sólo ha sido una, aunque
más del 99% de las veces sea así se puede dar el caso de que coincidan los dos comparadores
a la vez. De la misma forma si sabemos que sólo hay dos fuentes y una de ellas no ha
provocado la interrupción, por fuerzas ha tenido que ser la otra, podemos ahorrarnos la
comprobación.

Así que el flujo es así, leemos {\tt M1} para ver si la interrupción la ha provocado el
comparador de {\tt C1}, si ha sido así ejecutamos el código de manejo de LEDs. Si no,
saltamos directamente al manejo del altavoz (sabemos seguro que la fuente viene de ahí).

Tras el código del manejo de LEDs leemos {\tt M3} para saber si además de {\tt C1} ha
saltado también el comparador {\tt C3}. Si no ha saltado, lo más normal, salimso por
{\tt final}; si lo ha hecho, procesamos la interrupción con el código de manejo del altavoz
para luego salir de la RTI.

Estos programas no son fáciles de crear y nunca funcionan a la primera. Es una buena práctica
hacer funcionar por separado el código de los LEDs y el código del altavoz, y una vez
comprobemos que funcionan, aglutinarlo en una única RTI. De esta forma aislamos lo máximo
posible los errores que podamos cometer, es muy fácil equivocarse en una tontería y estar
dándole vueltas al código sin encontrar el fallo. A diferencia de los primeros capítulos
que disponíamos de {\tt gdb}, en Bare Metal no tenemos acceso a ningún depurador.

Prosigamos ahora con el código de manejo de LEDs. Recordemos que hemos complicado un poco
las cosas para emitir una secuencia en lugar de un simple parpadeo. Para ello mostramos
el código seguido de las variables empleadas en el mismo.

\begin{lstlisting}
        ldr     r2, =cuenta
        ldr     r3, =0b00000000010000100000110000001100
        str     r3, [r1, #GPCLR0]
        ldr     r3, [r2]          @cuenta
        subs    r3, #1
        movmi   r3, #5
        str     r3, [r2], #4      @cuenta
        ldr     r3, [r2, +r3, LSL #2]
        str     r3, [r1, #GPSET0]
        ldr     r3, [r0, #STCLO]
        ldr     r2, =200000       @5 Hz
        add     r3, r2
        str     r3, [r0, #STC1]
        [...]
cuenta: .word   0
secuen: .word   0b00000000000100000000000
        .word   0b00000000000010000000000
        .word   0b10000000000000000000000
        .word   0b00000100000000000000000
        .word   0b00000000000000000001000
        .word   0b00000000000000000000100
\end{lstlisting}

En la variable {\tt cuenta} almacenamos un contador que va desde 5 hasta 0, que actua
índice para el array {\tt secuen}. Al decrementar aprovechamos la propia instrucción de
resta para comprobar que se ha llegado al final de la cuenta (-1), y en dicho caso
restablecemos la cuenta a 5 mediante la instrucción de ejecución condicional {\tt movmi}.

Nótese que al escribir en la variable {\tt cuenta} hacemos un postincremento de 4, con el
cual apuntamos al array {\tt secuen} sin necesidad de una instrucción de suma específica.
En dicho array tenemos almacenadas las posiciones que corresponden los LEDs dentro del
registro {\tt GPSET0}, cada posición del array es para encender un LED en concreto. Antes
de esto hemos apagado todos los LEDs enviando el valor que codifica todos los LEDs al
registro {\tt GPCLR0}.

A parte de sacar la secuencia correspondiente debemos especificar cuándo será la siguiente
interrupción. Como hicimos en el ejemplo anterior, esto se resuelve leyendo el valor del
registro {\tt STCLO}, sumándole 200000 (200 milisegundos) y escribiéndolo en el comparador
{\tt STC1}.

Acabado el código de manejo de LEDs, ya sólo falta por explicar el manejo del altavoz.

\begin{lstlisting}
sonido: ldr     r2, =bitson
        ldr     r3, [r2]
        eors    r3, #1
        str     r3, [r2]
        mov     r3, #0b10000      @altavoz
        streq   r3, [r1, #GPSET0]
        strne   r3, [r1, #GPCLR0]
        ldr     r3, [r0, #STCLO]
        ldr     r2, =1136         @440 Hz
        add     r3, r2
        str     r3, [r0, #STC3]
        mov     r3, #0b1000
        str     r3, [r0, #STCS]
        [...]
bitson: .word   0
\end{lstlisting}

Es un calco de la rutina que hacía parpadear todos los LEDs en la lección anterior, cambiando
el valor que se envia a {\tt GPCLR0/GPSET0}, el comparador que es {\tt C3} en lugar de {\tt C1},
y el valor que sumamos al temporizador, que se corresponde a 440Hz en vez de 1Hz.

\subsection{Ejemplo cos pulsadores y FIQs}


\chapterend{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}