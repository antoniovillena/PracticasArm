\input{hackcapitulo.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapterbegin{Interrupciones hardware}
\label{chp:Interrupciones}
\minitoc

{\bf Objetivos}: En esta sesión vamos a realizar programas que
utilizan dispositivos de E/S haciendo uso del sistema de
interrupciones hardware. Para poder programar los distintos parámetros
que configuran el entorno de las interrupciones es necesario conocer de
forma detallada cómo funcionan los registros asociados, ya que
éste es el mecanismo mediante el cual el procesador se
comunica con los periféricos.

Hacemos incapié en lo de {\it hardware} porque las
{\it interrupciones software} no son más que las llamadas a sistema
que vimos en el capítulo anterior. Ambas comparten vector de interrupciones,
pero las {\it interrupciones software} son más bien llamadas a subrutinas.

\section{Lectura previa}

El microprocesador se encuentra en un entorno donde existen otros
componentes. La forma de comunicación más usual entre estos
componentes y el microprocesador se denomina interrupción.
Básicamente, una interrupción es una petición que se hace a la CPU
para que detenga el trabajo que esté realizando y ejecute una rutina
determinada. 

\subsection{El sistema de interrupciones del ARM}

Decimos que las interrupciones del ARM son {\bf vectorizadas}.
Cada tipo de interrupción lleva asociado un número (que llamamos
{\bf número de interrupción}, $NI$) que identifica el tipo de servicio a
realizar. En total hay 8 tipos de interrupciones.
A partir de dicho número se calcula la dirección a la que salta la CPU
para atender dicha interrupción. A diferencia de otras arquitecturas
donde los vectores contienen las direcciones de las rutinas de
tratamiento, en ARM no tenemos datos sino instrucciones. Cada vector
contiene normalmente un salto a la rutina de tratamiento correspondiente.
Dicha rutina se suele llamar RTI ({\bf Rutina
de Tratamiento de Interrupción}). En la arquitectura ARMv6
todos los vectores de interrupción se almacenan en una zona de memoria
llamada {\bf tabla de vectores de interrupción}. Esta tabla comienza
en la dirección física 0x00000000 (aunque puede cambiarse por
0xffff0000) y acaba en 0x0000001f y contiene en total 8 vectores de
interrupción. Cuando termina de ejecutarse una RTI,
el procesador continúa ejecutando la instrucción siguiente a la que se
estaba ejecutando cuando se produjo la interrupción.

Existen dos tipos de interrupciones: hardware y software. Las {\bf
interrupciones hardware} son aquellas en las que su activación está
condicionada por el hardware del sistema, ya sea por: 1) {\it
excepciones} provocadas en la ejecución de alguna instrucción o error
grave, o 2) provocadas por la placa base o por cualquier tarjeta
implicada en un canal de E/S.

\noindent La lista del vector de excepciones es la siguiente.

\begin{longtable}{ p{5cm} | p{1cm} | p{2cm} | p{4cm}}
\hline
{\bf Excepción} & {\bf NI} & {\bf Desplaz.} & {\bf Modo} \\ \hline
Reset                   & 0 & {\tt 0x00} & Supervisor \\ \hline
Instrucción no definida & 1 & {\tt 0x04} & No definido \\ \hline
Interrupción software   & 2 & {\tt 0x08} & Supervisor \\ \hline
Error en prefetch       & 3 & {\tt 0x0C} & Abort \\ \hline
Error en datos          & 4 & {\tt 0x10} & Abort \\ \hline
Reservado               & 5 & {\tt 0x14} & Reservado \\ \hline
IRQ                     & 6 & {\tt 0x18} & IRQ \\ \hline
FIQ                     & 7 & {\tt 0x1C} & FIQ \\ \hline
\label{tab:excepciones}
\caption{Vector de excepciones}
\end{longtable}

La última columna se refiere al {\it Modo de operación} que comentamos en el primer
capítulo, es un estado en el que se encuentra el procesador con una serie de privilegios
con respecto a otros modos y que gracias a ellos podemos construir un sistema operativo
con diferentes capas. Cada modo tiene sus propios registros {\tt sp} y {\tt lr} de tal
forma que no alteramos la pila de la secuencia de programa que interrumpimos. Incluso
el modo {\tt FIQ} tiene 5 registros generales propios (desde {\tt r8} hasta {\tt r12}),
de esta forma si los empleamos en nuestra rutina de tratamiento no tendremos que
salvaguardarlos en pila.

En la figura \ref{fig:tablareg} observamos los registros propios que contiene cada modo.
Como podemos ver todos los modos tienen como registros propios {\tt sp}, {\tt lr} y {\tt spsr}.
El modo {\tt FIQ} además tienes los 5 registros antes mencionados.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/tablaregistros.png}
  \caption{Registros según modo de operación}
  \label{fig:tablareg}
\end{figure}

{\it Reset} es la excepción que se produce al forzar un reinicio en dicha máquina. La
Raspberry no tiene pulsador de reset, pero sí un par de pines (sin montar) para que podamos
añadir un pulsador externo. Este conector se llama {\tt P6} en la Raspberry original y
{\tt RUN} en el modelo B+.

{\it Instrucción no definida} se produce cuando en el flujo de instrucciones nos encontramos
un código de operación que no se corresponde con ninguna instrucción. Normalmente esto se
produce por una corrupción en la memoria de programa o bien que hemos saltado erróneamente
a una zona donde hay datos. También se puede dar el caso de que intentemos ejecutar código
ARM para una plataforma más moderna y nos encontremos con una instrucción no soportada por el
procesador que tenemos.

Las {\it interrupciones software} son subrutinas que se incluyen en el
sistema operativo y que son llamadas desde el programa ejecutando la
instrucción {\tt swi \#n}. No interrumpen realmente nada, pero se
denominan así porque el mecanismo de funcionamiento es el mismo que en
las hardware.

Luego tenemos los errores en {\it prefetch} y {\it datos}. Un error de {\it prefetch} se produce
cuando tratamos de ejecutar una instrucción que momentos antes hemos modificado. Es poco
frecuente y para que se produzca debemos escribir código que sea automodificable, que es
una práctica no deseable y apenas utilizada en dicha arquitectura. Los errores de {\it datos}
son generados normalmente por el manejador de memoria y responden a fallos de alineación, de
traslación, de dominio o de permisos.

Lo siguiente es una entrada reservada, no tiene ninguna funcionalidad ahora
pero es probable que en futuras extensiones sí que la tenga.

Por último están las excepciones que nos interesan y que trataremos en este capítulo, que son
las interrupciones normales {\tt IRQ} y las interrupciones rápidas {\tt FIQ}.

Puesto que cada interrupción, $NI$, lleva asociada una rutina, de
alguna forma, se le debe indicar a la CPU en qué parte de la tabla de
vectores de interrupción se encuentra el vector de interrupción
asociado (es decir, la instrucción de salto a la rutina que debe
ejecutar cuando se produce la interrupción). La forma de hacerlo es multiplicar por
cuatro el número de interrupción para obtener un desplazamiento
($NI$*4). Se multiplica por 4 porque cada vector de interrupción
ocupa 4 bytes (es lo que ocupa una instrucción en ARM) y el primer
vector de interrupción que se almacena es el correspondiente al Reset.

Cuando se activa una interrupción, la CPU detiene su trabajo para
atenderla. Después, continúa su trabajo donde lo dejó. Los pasos a
seguir para que esto sea posible son:

\begin{enumerate}
  \item Cuando se activa la interrupción, se termina la ejecución de la
    instrucción en curso. A continuación hacemos una copia {\tt cpsr} en el registro
    propio {\tt spsr} correspondiente. De esta forma recordamos los flags de estado
    y el modo que había antes de la interrupción. Una vez hecha la copia se
    procede a cambiar {\tt cpsr}, conmutando al modo correspondiente
    según la tabla \ref{tab:excepciones}.

  \item Seguidamente a lo anterior almacenamos en {\tt lr} (en su registro propio del modo)
    el contenido de {\tt pc+4} (salvo si es un {\tt error en datos} que sería
    {\tt pc+8}). La razón de estos
    desplazamientos es puramente técnica, debido al segmentado de la CPU en
    el momento de hacer la copia el registro {\tt pc} se ha incrementado en 1 ó
    2 instrucciones.

  \item Luego saltamos al vector correspondiente ($NI$*4). La instrucción será un salto
    a la RTI correspondiente.

  \item Se ejecuta la rutina.

  \item La última instrucción de la rutina es {\tt subs pc, lr, \#4}, que se encarga
    de restaurar los flags originales y el modo copiando {\tt spsr} en {\tt cpsr}.
    Además volvemos al punto donde se interrumpió copiando de {\tt lr} a {\tt pc} (con el
    desplazamiento correspondiente).

   \item Se continúa ejecutando la tarea inicial.
\end{enumerate}

El registro {\tt cpsr} contiene 3 flags globales mediante los cuales podemos habilitar o
inhabilitar las interrupciones: uno para {\tt Abort} llamado {\tt A}, otro para
{\tt IRQ} llamado {\tt I} y el último para {\tt FIQ} denominado {\tt F}.

El manejo de estos flags corre a cuenta del usuario, en ningún momento la CPU enmascara
dichos flags. Por esta razón, si queremos dar prioridad a una interrupción en particular
para no ser interrumpidos nuevamente, debemos enmascarar dichos flags al comienzo de su RTI.

\subsection{Rutina de tratamiento de interrupción}

Es el segmento de código que se ejecuta para atender a una interrupción. Una vez se haya
ejecutado dicha rutina, retomamos la ejecución normal de nuestro programa, justo después de la instrucción
donde lo habíamos interrumpido. Cada rutina de tratamiento debe atender a todas las posibles
fuentes de interrupción de su mismo tipo, con lo que al comienzo de la interrupción se suelen
acceder a los registros asociados para detectar qué periférico ha causado la excepción y
actuar en consecuencia.

Como sólo nos interesan {\tt IRQ} y {\tt FIQ}, a lo sumo sólo tendremos que escribir dos
rutinas de tratamiento distintas. Si se produce una {\tt IRQ}, se ejecutará el código
que se encuentre en la dirección {\tt 0x0018}, mientras que si lo que salta es una {\tt IRQ},
la dirección a ejecutar será {\tt 0x001C}. La diferencia entre una {\tt IRQ} y una
{\tt FIQ} es que esta última tiene sus propios registros desde {\tt r8} hasta {\tt r12}
asociados al modo de operación, con lo que podemos prescindir del salvado y recuperación
de estos registros en la RTI, ahorrando un tiempo que en determinadas aplicaciones de
tiempo real puede ser decisivo.

El esqueleto de una RTI es el siguiente.

\begin{lstlisting}
irq_handler:
        push    {lista registros}
        ...
        pop     {lista registros}
        subs    pc, lr, #4
\end{lstlisting}

Vemos que a diferencia de las subrutinas donde salíamos con {\tt lr}, en una RTI salimos
con {\tt lr-4} (si es un {\tt error en datos} sería {\tt lr-8}), a ello se debe que la última
instrucción sea {\tt subs} en lugar de {\tt movs}.
¿Y porqué hay un sufijo {\tt s} al final
de la instrucción {\tt sub}? Pues porque se trata de instrucción especial que sirve para
restaurar el registro {\tt cpsr} que había antes de la interrupción.

Imaginemos que el programa principal está en modo supervisor y que la interrupción que
esperamos el del tipo IRQ.
Cada modo de operación (en particular el modo IRQ) tiene 3 registros replicados: {\tt sp}, {\tt lr} y {\tt spsr}.
Para evitar confusiones los nombramos con los sufijos de modo {\tt _svc} y {\tt _irq} correspondientes.
Cuando ocurre una interrupción pasamos de modo supervisor a modo IRQ, pero antes hemos guardado
el registro {\tt cpsr} en {\tt spsr_irq} (Saved Program Status Register).

Los registros {\tt sp_svc} y {\tt lr_svc} no se tocan para nada, con lo que no alteramos ni la
pila ni el registro de retorno del modo supervisor. El registro {\tt lr_irq} se carga apuntando a la
instrucción {\tt pc+4}. El resto de registros debemos salvarlos en pila si tenemos la intención
de modificarlos en nuestra RTI, al tener registro propio {\tt sp_irq} se trata de una pila
independiente que no interfiere con la principal {\tt sp_svc}. Luego se ejecuta el código
particular de la RTI, empleando a nuestro antojo los registros previamente salvados, y antes de
acabar la RTI recuperamos con su {\tt pop} correspondiente.

Al terminar la interrupción restauramos {\tt pc} partiendo {\tt lr_irq} y {\tt cpsr} del registro
{\tt spsr_irq}. Esto último fuerza un cambio de modo de IRQ a supervisor, conmutando {\tt sp} y {\tt lr}
a sus registros propios {\tt sp_svc} y {\tt lr_svc}. Con todo esto conseguimos volver exactamente
al punto del que partíamos minimizando las
operaciones que tiene que hacer la RTI y por tanto el retardo asociado. En otras arquitecturas
además de delegar en la RTI este trabajo, se usa la misma pila de programa, lo que puede
ocasionar problemas si nos importa lo que hay debajo de ésta.

\subsection{Inicialización en programa principal}

Nosotros vamos a tratar un caso sencillo de programa principal en el cual hacemos las
inicializaciones correspondientes para luego meternos en un bucle infinito y que las
interrupciones hagan su trabajo. Las cosas se pueden complicar metiendo código en
el programa principal concurrente con las interrupciones. Un ejemplo de esto sería
una rutina que dibuja la pantalla en el programa principal, mientras que se aceptan
interrupciones para registrar las pulsaciones del teclado.

Sin embargo nuestro programa principal tras la inicialización será una
instrucción que salta a sí misma continuamente, la misma {\tt infi: b infi} del capítulo
anterior salvo que esta vez no la usamos para dejar al sistema colgado.

El orden recomendado es el siguiente, aunque se pueden cambiar el mismo salvo el último punto.

\begin{enumerate}
  \item Escribimos en el vector de excepciones la instrucción de salto necesaria a nuestra RTI.
        Nosotros emplearemos una macro llamada {\tt ADDEXC} que tiene 2 parámetros, offset y
        dirección de la RTI. A grandes rasgos la macro genera y escribe el código de operación
        del salto, para ver los detalles consultar apéndice.
        En nuestros ejemplos tendremos IRQs y FIQs, por lo que como mucho haremos dos
        invocaciones a dicha macro (para dos RTIs distintas).
  \item Inicializamos el puntero de pila (registro {\tt sp}) en todos los modos de operación.
        Tienen que apuntar a zonas distintas donde sepamos que no habrá conflictos con la
        memoria de programa. En todos los ejemplos que veremos inicializamos la pila de FIQ
        a {\tt 0x4000}, la de IRQ a {\tt 0x8000} y la del modo Supervisor a {\tt 0x8000000}.
        Como la memoria de programa empieza en {\tt 0x8000} y la pila crece hacia abajo,
        tendremos 16K de pila en modo IRQ, otros 16K en modo FIQ y 128Mb a compartir entre
        programa principal y pila de programa.
  \item Escribimos código de inicialización ajeno al proceso de interrupción, como por ejemplo
        configurar los GPIOs a salidas donde queramos que actúe un LED.
  \item Ahora viene la inicialización de las interrupciones. Aquí le decimos al sistema qué fuentes
        pueden provocar interrupciones, escribiendo en los registros asociados. 
  \item El último paso es habilitar las interrupciones globalmente escribiendo en el registro
        {\tt cpsr}. Lo hacemos indirectamente vía otro registro, y la instrucción tiene otro
        nombre pero hace lo mismo que un {\tt mov}. En concreto se llama {\tt msr}, y también hay
        otra equivalente {\tt mrs} si lo que queremos es leer de {\tt cpsr} a un registro.
  \item Después de esto se acaba la inicialización y tendríamos el bucle infinito del que consta
        nuestro programa principal. Si todo ha ido bien las rutinas de tratamiento de interrupción
        se encargarán de hacer funcionar nuestro programa como queramos.
\end{enumerate}

Veamos más detalladamente e ilustremos con código los puntos anteriores.

\subsection{Escribimos en el vector de excepciones}

  Primero escribimos en {\tt r0} el valor cero que apunta al vector de excepciones.
  Luego invocamos la macro para una IRQ, pasándole la etiqueta de nuestra RTI {\tt irq_handler}.
\begin{lstlisting}
        mov     r0, #0        @apunto tabla excepciones
        ADDEXC  0x18, irq_handler
\end{lstlisting}

\subsection{Inicializamos punteros de pila}

La única forma de acceder a ellos es cambiando de modo y modificando el registro {\tt sp}. En
{\tt Bare Metal} nos olvidamos del modo Usuario, el sistema arranca en modo Supervisor y
nosotros nos mantenemos en dicho modo a no ser que haya una interrupción o querramos cambiar
un registro particular del modo como es el caso.

El modo viene indicado en la parte más baja del registro {\tt cpsr}, el cual modificaremos
con la instrucción especial {\tt msr}. Como sólo nos interesa cambiar el byte más bajo del
registro, añadimos el sufijo {\tt c} precedido de un guión bajo. Los otros 3 bytes se acceden
con {\tt x}, {\tt s} y {\tt f} respectivamente. En la figura \ref{fig:cpsr} vemos el contenido
completo del registro {\tt cpsr}.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/cpsr.png}
  \caption{Registro cpsr}
  \label{fig:cpsr}
\end{figure}

Y en la siguiente tabla vemos cómo se codifica el modo de operación.

\begin{longtable}{ p{1.8cm} | p{2cm} | p{5cm} | p{1cm} | p{1cm} }
\hline
{\bf Hex} & {\bf Binario} & {\bf Modo de operación} \\ \hline
0x10 & 10000 & Usuario        \\ \hline
0x11 & 10001 & FIQ            \\ \hline
0x12 & 10010 & IRQ            \\ \hline
0x13 & 10011 & Supervisor     \\ \hline
0x16 & 10110 & Monitor seguro \\ \hline
0x17 & 10111 & Abort          \\ \hline
0x1B & 11011 & Indefinido     \\ \hline
0x1F & 11111 & Sistema        \\ \hline
\end{longtable}

Finalmente tenemos que el código que inicializa los punteros de pila es el siguiente.

\begin{lstlisting}
        mov     r0, #0xd1     \@modo FIQ, FIQ&IRQ desact
        msr     cpsr_c, r0
        mov     sp, #0x4000
        mov     r0, #0xd2     \@modo IRQ, FIQ&IRQ desact
        msr     cpsr_c, r0
        mov     sp, #0x8000
        mov     r0, #0xd3     \@modo SVC, FIQ&IRQ desact
        msr     cpsr_c, r0
        mov     sp, #0x8000000
\end{lstlisting}

En concreto a {\tt 0x4000}, {\tt 0x8000} y {\tt 0x8000000} para los modos {\tt FIQ}, {\tt IRQ} y
{\tt Supervisor} respectivamente.

\subsection{Código de inicialización ajeno a interrupciones}

En nuestros ejemplos se trata de configurar los periféricos, por ejemplo indicar los puertos
GPIO de entrada y de salida, inicializar temporizadores. En casos más complejos tendríamos que
inicializar estructuras de datos, rellenar las tablas que sean precalculadas y en general
cualquier tarea de inicialización requerida para hacer funcionar nuestro programa.

El caso más recurrente en nuestros ejemplos es el de asignar el sentido a los pines GPIO.

\begin{lstlisting}
        ldr     r0, =GPBASE
        ldr     r1, =0b00000000000000000001001001001001
        str     r1, [r0, #GPFSEL0]
        ldr     r1, =0b00000000001000000000000000001001
        str     r1, [r0, #GPFSEL1]
        mov     r1, #0b00000000000000000000000001000000
        str     r1, [r0, #GPFSEL2]
\end{lstlisting}

\subsection{Inicializamos interrupciones localmente}

Consiste en escribir en los registros asociados dependiendo de las fuentes que querramos
activar. En este ejemplo habilitamos el comparador
{\tt C1} del temporizador como fuente de interrupción.

\begin{lstlisting}
        ldr     r0, =INTBASE
        mov     r1, #0b0010
        str     r1, [r0, #INTENIRQ1]
\end{lstlisting}

\subsection{Habilitamos interrupciones globalmente}

Se trata de poner a cero el bit correspondiente en {\tt cpsr}. El siguiente código habilita
interrupciones del tipo IRQ.

\begin{lstlisting}
        mov     r0, #0x53     @modo SVC, IRQ activo
        msr     cpsr_c, r0
\end{lstlisting}

\subsection{Resto del programa principal}

Como hemos adelantado, en todos nuestros ejemplos será un bucle infinito.

\begin{lstlisting}
bucle:  b       bucle
\end{lstlisting}



\subsection{Ejemplos de aplicación}

Todos los ejemplos que vamos a listar son para la placa que usaremos en el laboratorio
y para los siguientes modelos de Raspberry.

\begin{itemize}
  \item Modelo A.
  \item Modelo B revisión 2.0.
  \item Modelo B+ (empleando la parte izquierda del conector).
\end{itemize}

El modelo B revisión 1.0 tiene una asignación de pines ligeramente distinta, cambiando 3 de
los pines. Si dispones de esta versión tendrías que modificar el código de los ejemplos
según la tabla \ref{tab:berry}.

\subsection{Parpadeo de todos los LEDs}

Sería hacer lo mismo que en la lección anterior pero empleando interrupciones y aplicando
la salida simultáneamente a los 6 LEDs de la placa externa en lugar del LED que incluye
la Raspberry. La cadencia debe ser de un segundo.

Vamos a emplear otro temporizador, el {\tt System Timer}, distinto al de la lección anterior
que era el {\tt ARM Timer}. Los registros asociados al temporizador son los de la figura
\ref{fig:systim}.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/systemtimer.png}
  \caption{System Timer}
  \label{fig:systim}
\end{figure}

Básicamente con un contador de 64 bits y cuatro comparadores. El temporizador funciona a 1MHz,
por lo que cada microsegundo se incrementa la cuenta del contador. Está dividido en dos partes,
la parte baja {\tt CLO} y la parte alta {\tt CHI}. La parte alta no nos resulta interesante,
porque tarda poco más de una hora en incrementarse y no va asociado a ningún comparador. Los
comparadores son registros que se pueden modificar y se comparan con {\tt CLO}, en el momento
que uno de los 4 comparadores coincida y estén habilitadas las interrupciones para dicho
comparador, se produce una interrupción y se activa el correspondiente {\tt Mx}
asociado a {\tt CS} (para que en la RTI sepamos qué comparador ha provocado la interrupción).
Los comparadores {\tt C0} y {\tt C2} los emplea la GPU internamente, por lo que en nuestros
ejemplos nos ceñiremos a los comparadores {\tt C1} y {\tt C3}.

El temporizador ya está, luego tenemos los registros asociados a las interrupciones en la figura
\ref{fig:interrupciones}.

\begin{figure}[h]
  \centering
    \includegraphics[width=14cm]{graphs/interrupciones.png}
  \caption{Interrupciones}
  \label{fig:interrupciones}
\end{figure}

En este caso las {\tt FIQs} sólo tienen un registro de control asociado, quedando todo el detalle
en las {\tt IRQs}. Nosotros vamos a usar las {\tt IRQs} en este ejemplo. Hay tres grupos de tres
registros cada uno. El primer grupo sirve para indicar que hay una interrupción pendiente, el
segundo es para habilitar las interrupciones y el tercero para deshabilitarlas. Dentro de cada
grupo tenemos un registro básico que tiene una mezcla de todo y otros dos registros que
indican con más detalle la fuente de la interrupción. Dentro de la mezcla del registro básico
hay fuentes individuales {\tt GPU IRQ x} y bits que engloban a varias fuentes {\tt Bits in PR1},
que por ejemplo indica que el origen hay que buscarlo en el registro 1. En el registro 1 están
las primeras 32 posiciones de la tabla de interrupciones, mientras que en el registro 2 están
las 32 últimas.

La documentación oficial sobre la tabla de interrupciones está incompleta, pero buscando un poco
por internet se puede encontrar que las interrupciones asociadas al {\tt System Timer} se
controlan con los 4 primeros bits de la tabla (uno para cada comparador).

Ya estamos en condiciones para mostrar el código del ejemplo. En este primer ejemplo incluimos
la sección de constantes del fichero, en el resto listaremos a partir del {\tt .text}.

\begin{lstlisting}[caption={inter1.c},label={lst:codigoPract5_1}]
        .set    GPBASE,   0x20200000
        .set    GPFSEL0,        0x00
        .set    GPFSEL1,        0x04
        .set    GPFSEL2,        0x08
        .set    GPSET0,         0x1c
        .set    GPCLR0,         0x28
        .set    STBASE,   0x20003000
        .set    STCS,           0x00
        .set    STCLO,          0x04
        .set    STC1,           0x10
        .set    INTBASE,  0x2000b000
        .set    INTENIRQ1,     0x210
.text
        mov     r0, #0x18     @IRQ vector
        ldr     r1, =irq_handler
        bl      add_exception
        mov     r0, #0xd2     @IRQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000
        mov     r0, #0xd3     @SVC mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000000
        ldr     r0, =GPBASE
        mov     r1, #0b00000000000000000000001001000000
        str     r1, [r0, #GPFSEL0]
        ldr     r1, =0b00000000001000000000000000001001
        str     r1, [r0, #GPFSEL1]
        mov     r1, #0b00000000000000000000000001000000
        str     r1, [r0, #GPFSEL2]
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        add     r1, #2
        str     r1, [r0, #STC1]
        ldr     r0, =INTBASE
        mov     r1, #0b0010
        str     r1, [r0, #INTENIRQ1]
        mov     r0, #0x53     @SVC mode, IRQ enable
        msr     cpsr_c, r0
bucle:  b       bucle

add_exception:
        sub     r1, r0
        lsr     r1, #2
        sub     r1, #2
        orr     r1, #0xea000000
        str     r1, [r0]
        bx      lr

irq_handler:
        push    {r0, r1, r2}
        ldr     r0, =ledst
        ldr     r1, [r0]
        eors    r1, #1
        str     r1, [r0]
        ldr     r0, =GPBASE
        ldr     r1, =0b00000000010000100000110000001100
        streq   r1, [r0, #GPSET0]
        strne   r1, [r0, #GPCLR0]
        ldr     r0, =STBASE
        mov     r1, #0b0010
        str     r1, [r0, #STCS]
        ldr     r1, [r0, #STCLO]
        ldr     r2, =500000       @1 Hz
        add     r1, r2
        str     r1, [r0, #STC1]
        pop     {r0, r1, r2}
        subs    pc, lr, #4

ledst:  .word   0
\end{lstlisting}

Y vamos enumerando, por orden, los pasos que hemos seguido. En primer lugar apuntamos a nuestra
RTI en el vector de excepciones.

\begin{lstlisting}
        mov     r0, #0x18     \@IRQ vector
        ldr     r1, =irq_handler
        bl      add_exception
\end{lstlisting}

Luego inicializamos los punteros de pila.

\begin{lstlisting}
        mov     r0, #0xd2     @IRQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000
        mov     r0, #0xd3     @SVC mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000000
\end{lstlisting}

Lo siguiente es configurar los pines GPIO asociados a los 6 LEDs como salidas.

\begin{lstlisting}
        ldr     r0, =GPBASE
        mov     r1, #0b00000000000000000000001001000000
        str     r1, [r0, #GPFSEL0]
        ldr     r1, =0b00000000001000000000000000001001
        str     r1, [r0, #GPFSEL1]
        mov     r1, #0b00000000000000000000000001000000
        str     r1, [r0, #GPFSEL2]
\end{lstlisting}

Preparamos el comparador {\tt C1} para que al cabo de dos microsegundos nos proporcione la primera
interrupción.

\begin{lstlisting}
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        add     r1, #2
        str     r1, [r0, #STC1]
\end{lstlisting}

Para después habilitar las interrupciones asociadas al comparador {\tt C1}.

\begin{lstlisting}
        ldr     r0, =INTBASE
        mov     r1, #0b0010
        str     r1, [r0, #INTENIRQ1]
\end{lstlisting}

Y finalmente habilitar las interrupciones {\tt IRQ} globalmente, entrando luego en
el bucle infinito.

\begin{lstlisting}
        mov     r0, #0x53     @SVC mode, IRQ enable
        msr     cpsr_c, r0
bucle:  b       bucle
\end{lstlisting}

Ya hemos terminado con el programa principal, que como veremos más adelante va a ser
siempre muy parecido.

Lo interesante está en la RTI, que es donde hacemos parpadear los LEDs y configuramos
el comparador para la siguiente interrupción.

El estado de los LEDs (si están apagados o encendidos) lo guardamos en la variable
{\tt ledst}, que conmutamos entre cero y uno mediante un {\tt OR} exclusivo. Al
actualizar los {\tt flags} tras esta operación, tenemos que si el resultado fue
cero nos lo indica el {\tt flag Z} activo, mientras que estará inactivo en el
caso contrario (resultado 1). Mediante las instrucciones de ejecución condicional
{\tt streq} y {\tt strne} enviamos la orden al puerto que enciende los LEDs o al
puerto que los apaga, respectivamente.

\begin{lstlisting}
irq_handler:
        push    {r0, r1, r2}
        ldr     r0, =ledst
        ldr     r1, [r0]
        eors    r1, #1
        str     r1, [r0]
        ldr     r0, =GPBASE
        ldr     r1, =0b00000000010000100000110000001100
        streq   r1, [r0, #GPSET0]
        strne   r1, [r0, #GPCLR0]
\end{lstlisting}


Luego escribimos un 1 en el {\tt M1} de {\tt CS}, para resetear el estado de coincidencia, ya
que de lo contrario el gestor de interrupciones verá el bit siempre a 1 y no lanzará más
interrupciones. Resulta confuso tener que escribir un 1 en el registro para almacenar un 0, pero
de un modo similar a lo que ocurre con el registro {\tt GPCLR0} del GPIO es para ahorrar
operaciones y que la RTI sea más rápida. Así no hay que leer el registro, aplicar una máscara y
volver a escribir en el mismo registro, con una escritura es suficiente.

\begin{lstlisting}
        ldr     r0, =STBASE
        mov     r1, #0b0010
        str     r1, [r0, #STCS]
\end{lstlisting}

Luego tenemos que actualizar el registro comparador, de lo contrario tardará poco más
de una hora en cambiar de estado el LED (es lo que tarda el contador en dar una vuelta
completa). Para ello leemos el contador ({\tt CLO}) y le añadimos 500000 al valor leído. Como cada
cuenta equivale a un microsegundo, este añadido al contador supone medio segundo, lo
que nos da la cadencia de un segundo que buscamos. El resultado de la suma lo escribimos
en el comparador ({\tt C1}).

\begin{lstlisting}
        ldr     r1, [r0, #STCLO]
        ldr     r2, =500000       @1 Hz
        add     r1, r2
        str     r1, [r0, #STC1]
\end{lstlisting}

Por último restauramos los registros utilizados y salimos de la RTI. Más abajo tenemos la
definición de la variable {\tt ledst}, como no tenemos sección de datos aparte la ponemos
al final del código.

\begin{lstlisting}
        pop     {r0, r1, r2}
        subs    pc, lr, #4

ledst:  .word   0
\end{lstlisting}

\subsection{Parpadeo secuencial de LEDs con sonido por altavoz}

Vamos a complicar un poco las cosas. En la RTI anterior sabíamos de antemano que la única fuente
de interrupción es {\tt C1} del {\tt System Timer}. Por eso directamente hacíamos conmutar el
LED sin comprobar nada más, esto es porque sabemos que ningún otro evento provocará una {\tt IRQ}.

Ahora vamos a meter una segunda fuente de interrupción para controlar el altavoz. Sacar un tono
puro por el altavoz es equivalente a hacer parpadear un LED, lo único que cambia es que usamos
otro pin distinto {\tt GPIO 4} y aumentamos la frecuencia para que sea audible (a 1Hz el oído
humano no captaría sonido alguno). Utilizaremos la frecuencia estándar de afinación
de 440 Hz, que coincide con el tono de espera de marcado en la telefonía fija.

Por otro lado en lugar de hacer parpadear todos los LEDs lo que haremos es repetir una
secuencia de 6 posiciones en la que en todo momento sólo uno de los 6 LEDs está encendido, que
va cambiando de izquierda a derecha (aparentando movimiento) y cuando se llegue al sexto LED
comenzamos de nuevo desde el primero. Para dar más sensación de movimiento disminuimos el periodo
a 200 milisegundos.

La clave de todo está en saber cuál de los dos comparadores ha producido la interrupción (se
puede dar el caso en que salten los dos a la vez). Ésto se puede hacer de dos formas distintas:
o bien leemos el bit asociado {\tt systim\_cx} en el registro {\tt IRQ pending 1}, o bien leemos
el {\tt Mx} del registro {\tt CS}. Elegimos el segundo caso, así no gastamos otro registro más
para almacenar {\tt INTBASE}.

El código completo del ejemplo es el siguiente.

\begin{lstlisting}[caption={Parte de inter2.c},label={lst:codigoPract5_2}]
.text
        mov     r0, #0x18     @IRQ vector
        ldr     r1, =irq_handler
        bl      add_exception
        mov     r0, #0xd2     @IRQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000
        mov     r0, #0xd3     @SVC mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000000
        ldr     r0, =GPBASE
        mov     r1, #0b00000000000000000001001001000000
        str     r1, [r0, #GPFSEL0]
        ldr     r1, =0b00000000001000000000000000001001
        str     r1, [r0, #GPFSEL1]
        mov     r1, #0b00000000000000000000000001000000
        str     r1, [r0, #GPFSEL2]
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        add     r1, #2
        str     r1, [r0, #STC1]
        str     r1, [r0, #STC3]
        ldr     r0, =INTBASE
        mov     r1, #0b1010
        str     r1, [r0, #INTENIRQ1]
        mov     r0, #0x53     @SVC mode, IRQ enable
        msr     cpsr_c, r0
bucle:  b       bucle

add_exception:
        sub     r1, r0
        lsr     r1, #2
        sub     r1, #2
        orr     r1, #0xea000000
        str     r1, [r0]
        bx      lr

irq_handler:
        push    {r0, r1, r2, r3}
        ldr     r0, =STBASE
        ldr     r1, =GPBASE
        ldr     r2, [r0, #STCS]
        ands    r2, #0b0010
        beq     sonido
        ldr     r2, =cuenta
        ldr     r3, =0b00000000010000100000110000001100
        str     r3, [r1, #GPCLR0]
        ldr     r3, [r2]          @cuenta
        subs    r3, #1
        movmi   r3, #5
        str     r3, [r2], #4      @cuenta
        ldr     r3, [r2, +r3, LSL #2]
        str     r3, [r1, #GPSET0]
        mov     r3, #0b0010
        str     r3, [r0, #STCS]
        ldr     r3, [r0, #STCLO]
        ldr     r2, =200000       @5 Hz
        add     r3, r2
        str     r3, [r0, #STC1]
        ldr     r3, [r0, #STCS]
        ands    r3, #0b0100
        beq     final
sonido: ldr     r2, =bitson
        ldr     r3, [r2]
        eors    r3, #1
        str     r3, [r2]
        mov     r3, #0b10000      @altavoz
        streq   r3, [r1, #GPSET0]
        strne   r3, [r1, #GPCLR0]
        mov     r3, #0b1000
        str     r3, [r0, #STCS]
        ldr     r3, [r0, #STCLO]
        ldr     r2, =1136         @440 Hz
        add     r3, r2
        str     r3, [r0, #STC3]
final:  pop     {r0, r1, r2, r3}
        subs    pc, lr, #4

bitson: .word   0
cuenta: .word   0
secuen: .word   0b00000000000100000000000
        .word   0b00000000000010000000000
        .word   0b10000000000000000000000
        .word   0b00000100000000000000000
        .word   0b00000000000000000001000
        .word   0b00000000000000000000100
\end{lstlisting}

Como es muy parecido al ejemplo de antes, sólo vamos a comentar las diferencias que encontremos.
La primera de ellas es que además de los 6 GPIOs de los LEDs, configuramos como salida un séptimo
pin, el GPIO 4, para manejar el altavoz.

\begin{lstlisting}
        ldr     r0, =GPBASE
        mov     r1, #0b00000000000000000001001001000000
        str     r1, [r0, #GPFSEL0]
\end{lstlisting}

El siguiente código es para incluir el comparador {\tt C3}, tanto para proporcionar la primera
interrupción como para habilitarla individualmente.

\begin{lstlisting}
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        add     r1, #2
        str     r1, [r0, #STC1]
        str     r1, [r0, #STC3]
        ldr     r0, =INTBASE
        mov     r1, #0b1010
        str     r1, [r0, #INTENIRQ1]
\end{lstlisting}

Ya hemos acabado con el programa principal, veamos ahora la RTI. Primero explicamos mostramos
el esquema general y luego las rutinas individuales tanto para el manejo de LEDs como para el
altavoz.

\begin{lstlisting}
irq_handler:
        push    {r0, r1, r2, r3}
        ldr     r0, =STBASE
        ldr     r1, =GPBASE
        ldr     r2, [r0, #STCS]
        ands    r2, #0b0010
        beq     sonido

        [ manejo de LEDs ]

        ldr     r3, [r0, #STCS]
        ands    r3, #0b0100
        beq     final
sonido:
        [ manejo de altavoz ]

final:  pop     {r0, r1, r2, r3}
        subs    pc, lr, #4
\end{lstlisting}

Los registros {\tt r0} y {\tt r1} los hacemos apuntar a la base del {\tt System Timer} y del
{\tt GPIO} y no tocamos dichos valores durante toda la interrupción, vamos a estar
constantemente leyendo y escribiendo registros y no es plan de tener que cargar la
base cada vez.

Es un error muy habitual suponer que la fuente de la interrupción sólo ha sido una, aunque
más del 99% de las veces sea así se puede dar el caso de que coincidan los dos comparadores
a la vez. De la misma forma si sabemos que sólo hay dos fuentes y una de ellas no ha
provocado la interrupción, por fuerzas ha tenido que ser la otra, podemos ahorrarnos la
comprobación.

Así que el flujo es así, leemos {\tt M1} para ver si la interrupción la ha provocado el
comparador de {\tt C1}, si ha sido así ejecutamos el código de manejo de LEDs. Si no,
saltamos directamente al manejo del altavoz (sabemos seguro que la fuente viene de ahí).

Tras el código del manejo de LEDs leemos {\tt M3} para saber si además de {\tt C1} ha
saltado también el comparador {\tt C3}. Si no ha saltado, lo más normal, salimso por
{\tt final}; si lo ha hecho, procesamos la interrupción con el código de manejo del altavoz
para luego salir de la RTI.

Estos programas no son fáciles de crear y nunca funcionan a la primera. Es una buena práctica
hacer funcionar por separado el código de los LEDs y el código del altavoz, y una vez
comprobemos que funcionan, aglutinarlo en una única RTI. De esta forma aislamos lo máximo
posible los errores que podamos cometer, es muy fácil equivocarse en una tontería y estar
dándole vueltas al código sin encontrar el fallo. A diferencia de los primeros capítulos
que disponíamos de {\tt gdb}, en Bare Metal no tenemos acceso a ningún depurador.

Prosigamos ahora con el código de manejo de LEDs. Recordemos que hemos complicado un poco
las cosas para emitir una secuencia en lugar de un simple parpadeo. Para ello mostramos
el código seguido de las variables empleadas en el mismo.

\begin{lstlisting}
        ldr     r2, =cuenta
        ldr     r3, =0b00000000010000100000110000001100
        str     r3, [r1, #GPCLR0]
        ldr     r3, [r2]          @cuenta
        subs    r3, #1
        movmi   r3, #5
        str     r3, [r2], #4      @cuenta
        ldr     r3, [r2, +r3, LSL #2]
        str     r3, [r1, #GPSET0]
        mov     r3, #0b0010
        str     r3, [r0, #STCS]
        ldr     r3, [r0, #STCLO]
        ldr     r2, =200000       @5 Hz
        add     r3, r2
        str     r3, [r0, #STC1]
        [...]
cuenta: .word   0
secuen: .word   0b00000000000100000000000
        .word   0b00000000000010000000000
        .word   0b10000000000000000000000
        .word   0b00000100000000000000000
        .word   0b00000000000000000001000
        .word   0b00000000000000000000100
\end{lstlisting}

En la variable {\tt cuenta} almacenamos un contador que va desde 5 hasta 0, que actua
índice para el array {\tt secuen}. Al decrementar aprovechamos la propia instrucción de
resta para comprobar que se ha llegado al final de la cuenta (-1), y en dicho caso
restablecemos la cuenta a 5 mediante la instrucción de ejecución condicional {\tt movmi}.

Nótese que al escribir en la variable {\tt cuenta} hacemos un postincremento de 4, con el
cual apuntamos al array {\tt secuen} sin necesidad de una instrucción de suma específica.
En dicho array tenemos almacenadas las posiciones que corresponden los LEDs dentro del
registro {\tt GPSET0}, cada posición del array es para encender un LED en concreto. Antes
de esto hemos apagado todos los LEDs enviando el valor que codifica todos los LEDs al
registro {\tt GPCLR0}.

A parte de sacar la secuencia correspondiente debemos especificar cuándo será la siguiente
interrupción. Como hicimos en el ejemplo anterior, esto se resuelve leyendo el valor del
registro {\tt STCLO}, sumándole 200000 (200 milisegundos) y escribiéndolo en el comparador
{\tt STC1}.

Acabado el código de manejo de LEDs, ya sólo falta por explicar el manejo del altavoz.

\begin{lstlisting}
sonido: ldr     r2, =bitson
        ldr     r3, [r2]
        eors    r3, #1
        str     r3, [r2]
        mov     r3, #0b10000      @altavoz
        streq   r3, [r1, #GPSET0]
        strne   r3, [r1, #GPCLR0]
        mov     r3, #0b1000
        str     r3, [r0, #STCS]
        ldr     r3, [r0, #STCLO]
        ldr     r2, =1136         @440 Hz
        add     r3, r2
        str     r3, [r0, #STC3]
        [...]
bitson: .word   0
\end{lstlisting}

Es un calco de la rutina que hacía parpadear todos los LEDs en la lección anterior, cambiando
el valor que se envia a {\tt GPCLR0/GPSET0}, el comparador que es {\tt C3} en lugar de {\tt C1},
y el valor que sumamos al temporizador, que se corresponde a 440Hz en vez de 1Hz.

\subsection{Manejo de FIQs y sonidos distintos para cada LED}

Este ejemplo es muy parecido al anterior pero con cambios sutiles. El hecho de cambiar una de
las dos IRQs por una FIQ incluso simplifica el código, ya que tienen distintas RTIs y en cada
una la fuente de interrupción es única, por lo que no hay que comprobar nada ni hacer saltos.

Empecemos con el programa principal. Aquí sí que hay cambios porque tenemos que agregar un
elemento nuevo al vector de excepciones, inicializar el puntero de pila del modo FIQ y activar
la fuente de interrupción FIQ local y globalmente.

\begin{lstlisting}[caption={Programa principal de inter3.c},label={lst:codigoPract5_1}]
.text
        mov     r0, #0x18     @IRQ vector
        ldr     r1, =irq_handler
        bl      add_exception
        mov     r0, #0x1c     @FIQ vector
        ldr     r1, =fiq_handler
        bl      add_exception
        mov     r0, #0xd1     @FIQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x4000
        mov     r0, #0xd2     @IRQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000
        mov     r0, #0xd3     @SVC mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000000
        ldr     r0, =GPBASE
        mov     r1, #0b00000000000000000001001001000000
        str     r1, [r0, #GPFSEL0]
        ldr     r1, =0b00000000001000000000000000001001
        str     r1, [r0, #GPFSEL1]
        mov     r1, #0b00000000000000000000000001000000
        str     r1, [r0, #GPFSEL2]
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        add     r1, #2
        str     r1, [r0, #STC1]
        str     r1, [r0, #STC3]
        ldr     r0, =INTBASE
        mov     r1, #0b0010
        str     r1, [r0, #INTENIRQ1]
        mov     r1, #0x80 | 3
        str     r1, [r0, #INTFIQCON]
        mov     r0, #0x13     @SVC mode, FIQ&IRQ enable
        msr     cpsr_c, r0
bucle:  b       bucle
\end{lstlisting}

Lo único nuevo es la activación local de las interrupciones para el comparador {\tt C3} del
{\tt System Timer}, lo hacemos sobre un registro {\tt FIQ control ó INTFIQCON} que hemos
mostrado en la figura \ref{fig:interrupciones}, sin embargo falta saber cuál es la lista
de fuentes de interrupción.

\begin{longtable}{ p{2cm} | p{6cm}}
\hline
{\bf Índice} & {\bf Fuente} \\ \hline
0-63  & Interrupciones IRQ 1 y 2 (ver figura \ref{fig:interrupciones})  \\ \hline
64    & ARM Timer  \\ \hline
65    & ARM Mailbox \\ \hline
66    & ARM Doorbell 0 \\ \hline
67    & ARM Doorbell 1 \\ \hline
68    & GPU0 detenida \\ \hline
69    & GPU1 detenida \\ \hline
70    & Acceso ilegal de tipo 1 \\ \hline
71    & Acceso ilegal de tipo 2 \\ \hline
\end{longtable}

Son las mismas fuentes que en IRQ pero condensadas en un único registro. De 0 a 31 coincide
con la tabla {\tt IRQ 1}, de 32 a 63 con {\tt IRQ 2} y de 64 en adelante con {\tt IRQ Basic}.
Nosotros queremos {\tt C3}, que es el bit 3 del {\tt IRQ 1}, por tanto índice 3 para la fuente
{\tt FIQ}. Como veis, la única pega que tienen las FIQ es que sólo admite una fuente de
interrupción. Además del índice ponemos el bit 7 a uno para indicar que queremos habilitar
dicha fuente {\tt 0x80 | 3}.

Ahora veamos el manejador IRQ (la RTI), que como hemos adelantado, es más sencilla que en el
ejemplo anterior.

\begin{lstlisting}
irq_handler:
        push    {r0, r1, r2}
        ldr     r0, =GPBASE
        ldr     r1, =cuenta
        ldr     r2, =0b00000000010000100000110000001100
        str     r2, [r0, #GPCLR0]
        ldr     r2, [r1]        @cuenta
        subs    r2, #1
        movmi   r2, #5
        str     r2, [r1], #4    @cuenta
        ldr     r2, [r1, +r2, LSL #3]
        str     r2, [r0, #GPSET0]
        ldr     r0, =STBASE
        mov     r2, #0b0010
        str     r2, [r0, #STCS]
        ldr     r2, [r0, #STCLO]
        ldr     r1, =500000     @2 Hz
        add     r2, r1
        str     r2, [r0, #STC1]
        pop     {r0, r1, r2}
        subs    pc, lr, #4
\end{lstlisting}

Observamos que al acceder a la tabla {\tt secuen} multiplicamos el índice por 8 en lugar de
por 4. Esto es así porque hemos incluído en dicha tabla el valor de la longitud de onda (inverso
de la frecuencia) con la que queremos que suene cada LED, la zona de datos es ésta.

\begin{lstlisting}
bitson: .word   0
cuenta: .word   0
secuen: .word   0b00000000000100000000000
        .word   716
        .word   0b00000000000010000000000
        .word   758
        .word   0b10000000000000000000000
        .word   851
        .word   0b00000100000000000000000
        .word   956
        .word   0b00000000000000000001000
        .word   1012
        .word   0b00000000000000000000100
        .word   1136
\end{lstlisting}

Serían las notas puras que van después del LA estándar de 440Hz (1136), cuyos semitonos se
obtienen multiplicando la frecuencia por raíz duodécima de 2, que es aproximadamente 1,05946.
Las notas serían, en hercios: LA (440), SI (493,88), DO (523,25), RE (587,33), MI (659,26) y
FA (698,46).

Finalmente tenemos el manejador de FIQ asociado al altavoz. La elección de la fuente de
interrupción es arbitraria, hemos escogido FIQ para el altavoz porque se ejecutará más veces
que el cambio de LEDs, concretamente 220 veces más con la nota más grave. En estos ejemplos
no importa, pero en casos reales donde el tiempo de CPU es un recurso limitado, los ciclos
que nos ahorramos con una FIQ en un proceso crítico pueden ser determinantes.

\begin{lstlisting}
fiq_handler:
        ldr     r8, =GPBASE
        ldr     r9, =bitson
        ldr     r10, [r9]
        eors    r10, #1
        str     r10, [r9], #4
        ldr     r10, [r9], #8
        ldr     r9, [r9, +r10, LSL #3]
        mov     r10, #0b10000   @altavoz
        streq   r10, [r8, #GPSET0]
        strne   r10, [r8, #GPCLR0]
        ldr     r8, =STBASE
        mov     r10, #0b1000
        str     r10, [r8, #STCS]
        ldr     r10, [r8, #STCLO]
        add     r10, r9
        str     r10, [r8, #STC3]
        subs    pc, lr, #4
\end{lstlisting}

El código sería idéntico al de una IRQ si no fuera porque empleamos registros a partir de
{\tt r8} en lugar de a partir de {\tt r0}, y no los salvaguardamos con las instrucciones
{\tt push/pop}. La razón es que el modo de operación FIQ es el único que tiene sus propios
registros {\tt r8-r12} (ver figura \ref{fig:tablareg}) con el objetivo de no perder el tiempo
guardando y recuperando datos de la pila. En situaciones más críticas podemos incluso ubicar
la RTI justo al final del vector de excepciones. Esta tabla no contiene datos, sino instrucciones,
y lo que hace la CPU cuando ocurre una excepción es saltar (ejecutar) a la dirección asociada en
dicho vector. Así que cada elemento es una instrucción de salto que apunta a su RTI
correspondiente, de no ser un salto se solaparía con el siguiente elemento del vector. Excepto
el último elemento del vector, que no se solaparía con nada y que corresponde a las
interrupciones FIQ. Se ha escogido intencionalmente así para ahorrarse el salto inicial.

Ya hemos visto casi todos los elementos de la placa externa. Lo único que nos falta por ver
son los pulsadores, eso es lo que veremos en el siguiente ejemplo.

\subsection{Control de luces/sonido con pulsadores en lugar temporizadores}

Los pulsadores izquierdo y derecho de nuestra placa externa están asociados a los
puertos {\tt GPIO 21} y {\tt GPIO 9} respectivamente. Veremos cómo se genera una
interrupción al pulsar cualquiera de los mismos, aunque desde un punto de vista
práctico lo que se hace normalmente es leer todas las entradas a la vez períodicamente
(puede ser una RTI asociada a un temporizador) y almacenarlas en un array.

Desde un punto de vista eléctrico un pulsador no es más que un interruptor que deja pasar
la corriente cuando está pulsado y se queda en circuito abierto en su posición de reposo
(sin pulsar). De los dos contactos que tiene, uno se conecta a masa y el otro al pin de
entrada de la Raspberry. Así que cuando lo pulsamos hacemos un corto que llevaría los cero
voltios de la masa al pin de entrada (enviamos un cero lógico), pero cuando está sin pulsar
no enviamos nada al pin, éste se queda en lo que se denomina alta impedancia.

Para solventar ésto hay dos opciones, o conectar externamente una resistencia entre el pin y
los 3.3V de la alimentación, o bien configurar el puerto GPIO para que lo haga internamente
(dentro del chip) con algo equivalente a una resistencia. Como nuestro circuito pulsador no
tiene resistencia externa, en nuestro ejemplo no tenemos más remedio que configurar la interna.

Las entradas no hay que configurarlas, o mejor dicho, cuando escribimos en los registros
{\tt GPFSELx} lo hacemos rellenando con valores a {\tt 000} los pines que no usamos, que se
corresponde con la función de entrada.

Nuestro programa principal tendrá lo de siempre, más la configuración de las resistencias
{\tt pull-up} (se llaman así cuando se conectan a alimentación, cuando lo hacen a masa se
llamarían {\tt pull-down}) y por último cambiamos la fuente de interrupción que antes se
encargaba de cambiar el estado de las luces. Si antes teníamos un temporizador que
incrementaba la secuencia de luces, ahora tenemos dos pulsadores, uno para incrementar y
otro para decrementar la secuencia.

Vamos al datasheet de periféricos del BCM2835 y observamos en la tabla (se corresponde con
IRQ 2) las siguientes entradas.

\begin{lstlisting}
gpio_int[0]
gpio_int[1]
gpio_int[2]
gpio_int[3]
\end{lstlisting}

Y como es habitual, no se explica nada más. Podríamos ponernos a probar nosotros mismos, pero
una simple búsqueda en internet damos con un usuario (cdbrown) en los foros de raspberry.org
que se ha encontrado con el mismo problema, y ha hecho un simple experimento forzando
interrupciones sobre los puertos GPIO 4, 17, 30, 31 y 47. La tabla de resultados es ésta.

\begin{lstlisting}
GPIO pin:         4    17   30   31   47
gpio_irq0 (49)    Y    Y    Y    Y    N
gpio_irq1 (50)    N    N    Y    Y    N
gpio_irq2 (51)    N    N    N    N    Y
gpio_irq3 (52)    Y    Y    Y    Y    Y
\end{lstlisting}

Una {\tt Y} indica que se produce la interrupción. Podemos concluir que si queremos una fuente
que salte con cualquier interrupción (ya la configuraremos individualmente en los registros GPIO)
esa es la {\tt gpio\_irq3}.

Por suerte la parte de documentación que afecta a la configuración de los pull-ups está más
completa.

{\it
The GPIO Pull-up/down Clock Registers control the actuation of internal pull-downs on 
the respective GPIO pins. These registers must be used in conjunction with the GPPUD 
register  to  effect  GPIO  Pull-up/down  changes.  The  following  sequence  of  events  is 
required: 
1.  Write to GPPUD to set the required control signal(i.e. Pull-up or Pull-Down or neither 
to remove the current Pull-up/down) 
2.  Wait 150 cycles – this provides the required set-up time for the control signal 
3.  Write to GPPUDCLK0/1 to clock the control signal into the GPIO pads you wish to 
modify – NOTE only the pads which receive a clock will bemodified, all others will 
retain their previous state. 
4.  Wait 150 cycles – this provides the required hold time for the control signal 
5.  Write to GPPUD to remove the control signal 
6.  Write to GPPUDCLK0/1 to remove the clock}

Una de las cosas que tenemos que hacer es esperar 150 ciclos (como mínimo). Como
sabemos que un salto condicional tarda al menos dos ciclos en ejecutarse, nuestra rutina
de retardo sería la siguiente.

\begin{lstlisting}
wait:   mov     r2, #50
wait1:  subs    r2, #1
        bne     wait1
        bx      lr
\end{lstlisting}

Y por último, el programa principal quedaría así.

\begin{lstlisting}[caption={Programa principal de inter4.c},label={lst:codigoPract5_1}]
.text
        mov     r0, #0x18     @IRQ vector
        ldr     r1, =irq_handler
        bl      add_exception
        mov     r0, #0x1c     @FIQ vector
        ldr     r1, =fiq_handler
        bl      add_exception
        mov     r0, #0xd1     @FIQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x4000
        mov     r0, #0xd2     @IRQ mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000
        mov     r0, #0xd3     @SVC mode, FIQ&IRQ disable
        msr     cpsr_c, r0
        mov     sp, #0x8000000
        ldr     r0, =GPBASE
        mov     r1, #0b00000000000000000001001001000000
        str     r1, [r0, #GPFSEL0]
        ldr     r1, =0b00000000001000000000000000001001
        str     r1, [r0, #GPFSEL1]
        mov     r1, #0b00000000000000000000000001000000
        str     r1, [r0, #GPFSEL2]
        mov     r1, #0b00000000000000000000100
        str     r1, [r0, #GPSET0]
        mov     r1, #2
        str     r1, [r0, #GPPUD]
        bl      wait
        ldr     r1, =0b00001000000000000000001000000000
        str     r1, [r0, #GPPUDCLK0]
        bl      wait
        mov     r2, #0
        str     r2, [r0, #GPPUD]
        str     r1, [r0, #GPREN0]
        ldr     r0, =STBASE
        ldr     r1, [r0, #STCLO]
        add     r1, #2
        str     r1, [r0, #STC1]
        ldr     r0, =INTBASE
        mov     r1, #0b00000000000100000000000000000000
        str     r1, [r0, #INTENIRQ2]
        mov     r1, #0x80 | 1
        str     r1, [r0, #INTFIQCON]
        mov     r0, #0x13     @SVC mode, FIQ&IRQ enable
        msr     cpsr_c, r0
bucle:  b       bucle
\end{lstlisting}

El valor escrito en {\tt GPPUD} es un 2, que se corresponde con {\tt pull-ups} (para pull-downs
sería un 1 y para desactivarlo un 0). En {\tt GPPUDCLK0} indicamos que queremos conectar esas
resistencias a los puertos GPIO 9 y 21 (pulsadores), y en {\tt GPREN0} le decimos al controlador
de interrupciones que esos pines serán los únicos que provoquen interrupciones, concretamente
flancos con de subida síncronos (justo en el momento en que el botón toca fondo).

El manejador FIQ es idéntico al de la lección anterior, saca el sonido que corresponde al LED
por el altavoz, lo único que empleando {\tt C1} en lugar de {\tt C3}.

Lo más relevante de este ejemplo está en la RTI asociada a la IRQ, que es la siguiente.

\begin{lstlisting}
irq_handler:
        push    {r0, r1, r2}
        ldr     r0, =GPBASE
        ldr     r1, =cuenta
        ldr     r2, =0b00000000010000100000110000001100
        str     r2, [r0, #GPCLR0]
        ldr     r2, [r0, #GPEDS0]
        ands    r2, #0b00000000000000000000001000000000
        beq     incre
        str     r2, [r0, #GPEDS0]
        ldr     r2, [r1]        @cuenta
        subs    r2, #1
        movmi   r2, #5
        b       conti
incre:  mov     r2, #0b00001000000000000000000000000000
        str     r2, [r0, #GPEDS0]
        ldr     r2, [r1]        @cuenta
        add     r2, #1
        cmp     r2, #6
        moveq   r2, #0
conti:  str     r2, [r1], #4    @cuenta
        ldr     r2, [r1, +r2, LSL #3]
        str     r2, [r0, #GPSET0]
        pop     {r0, r1, r2}
        subs    pc, lr, #4
\end{lstlisting}

Tenemos una bifurcación (saltos condicionales) debido a que cada botón es una fuente distinta
de interrupción y tenemos que distinguir qué botón se ha pulsado. Aquí por suerte tenemos
un registro totalmente análogo al {\tt STCS} de los temporizadores. Se llama {\tt GPEDS0}
(también hay otro {\tt GPEDS1} para los GPIOs de 32 a 53 que no necesitamos) y sirve tanto
para saber qué fuente ha producido la interrupción como para resetear su estado (y así permitir
volver a ser interrumpidos por el mismo pin GPIO).

Con la instrucción {\tt ands} comprobamos si un determinado bit está a 1 y lo indicamos en el
flag Z. También podría valer la instrucción {\tt tst}, que tiene la ventaja de no destruir
el registro a la salida (de la misma forma que {\tt cmp} es el equivalente no destructivo de
{\tt subs}).

Y por último tenemos que sacar la secuencia inversa a la que teníamos para que al pulsar el
botón izquierdo las luces vayan hacia la izquierda y que con el botón derecho vayan hacia
el otro lado. Si la secuencia de izquierda a derecha era  (5, 4, 3, 2, 1, 0, 5, 4...), la
inversa sería (0, 1, 2, 3, 4, 5, 0, 1...). Es decir, incrementamos y cuando llegamos al 6
lo convertimos en un cero. Ésto se hace con el siguiente fragmento.

\begin{lstlisting}
        add     r2, #1
        cmp     r2, #6
        moveq   r2, #0
\end{lstlisting}

Nótese que aquí la opción destructiva {\tt subs} no nos vale porque necesitamos el valor del
registro después. Sí que podemos cambiarlo por un {\tt teq} (la alternativa no destructiva
de {\tt eors}).

\section{Ejercicios}

\subsection{Todo con IRQs}

Modifica el último ejemplo ({\tt inter4.c}) para controlar el altavoz también con IRQs,
prescindiendo totalmente de las interrupciones FIQs.

\subsection{Alargar secuencia a 10 y parpadeo}

Partiendo de {\tt inter4.c} (o del resultado del ejercicio anterior) haz las siguientes
modificaciones. Si te resulta más cómodo, realízalas por orden.

\begin{itemize}
  \item Sacar de la secuencia el LED 6 (el de más a la derecha) y ponerlo a parpadear
        continuamente con una cadencia de un segundo. En este momento tendrás que acortar
        la secuencia a 5.
  \item Duplica la secuencia a 10. Para ello utiliza el código Morse aplicado a los dígitos
        (todos tienen longitud 5). Cambia el punto (tono corto) por LED apagado y el guión
        (tono largo) por LED encendido. Por supuesto los nuevos códigos tendrán su sonido
        asociado, sigue las notas (saltándote sostenidos y bemoles) para completar la tabla.
\end{itemize}

\subsection{Tope de secuencia y limitar sonido}

Partiendo de {\tt inter4.c} (o del resultado del ejercicio anterior) haz las siguientes
modificaciones. Si te resulta más cómodo, realízalas por orden.

\begin{itemize}
  \item Hasta ahora si llegamos al límite de la secuencia hemos comenzado por el principio,
        haciendo que la secuencia sea circular tanto en un sentido como en otro. Pues bien,
        ahora tienes que detectar dichos límites (tanto superior como inferior), poniendo
        una especie de tope al llegar al límite, que impida avanzar más. En caso de intentar
        avanzar en el sentido prohibido al llegar a un tope, en lugar de sacar el sonido que
        corresponda por el altavoz, auméntalo una escala (tope superior) o disminúyelo también
        una escala (tope inferior).
  \item Como habrás observado el sonido continuo resulta un tanto molesto después de un tiempo.
        Y con la indicación de los LEDs tenemos información suficiente para saber en qué
        posición de la secuencia estamos. Altera el programa para que sólamente suene el altavoz
        mientras el botón está pulsado, o lo que es lo mismo, para el sonido del altavoz cuando
        detectes un flanco de bajada en la señal GPIO correspondiente.
\end{itemize}

\subsection{Reproductor de melodía sencilla}

Escoge una melodía sencilla y trata de interpretarla. Emplea los LEDs a tu gusto para que
cambien según la nota que esté sonando. Implementa las siguientes funciones en los pulsadores.

\begin{itemize}
  \item \textbf{Pulsador izquierdo.} Cambio de tempo. La melodía debe comenzar a tempo normal (llamémoslo 1),
        y variar desde tempo lento (0) y tempo rápido (2) según la secuencia (0, 1, 2, 0...) cada
        vez que pulsemos dicho botón.
  \item \textbf{Pulsador derecho.} Iniciar/Parar/Reanudar. La melodía tiene una duración determinada y
        cuando acaba deja de sonar, no suena en modo bucle todo el tiempo. Si pulsamos dicho botón
        cuando está en silencio después que haya sonado la melodía, la función correspondiente
        sería la de iniciarla. Si lo pulsamos durante la reproducción actuaría a modo de pause
        (los LEDs se quedan congelados en el estado en el que estén), parando y reanudando la
        reproducción de la música.
\end{itemize}

En este ejemplo puedes profundizar todo lo que quieras. Por ejemplo empieza codificando los
silencios, éstos son muy importantes y también forman parte de la melodía. Un segundo paso sería
codificar la duración de las notas, si no lo has hecho ya. También es posible tener varios
instrumentos sonando a la vez, aunque sólo dispongamos de un altavoz, busca por internet {\tt
1-bit music} o {\tt beeper music} si quieres saber cómo se hace.

\chapterend{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
